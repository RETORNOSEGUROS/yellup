<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arena Torneio - Yellup</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0e141b 0%, #1a2332 100%);
      color: #e7eef7;
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Header da Arena */
    .arena-header {
      background: linear-gradient(180deg, rgba(139, 92, 246, 0.3), rgba(0, 0, 0, 0.4));
      backdrop-filter: blur(20px);
      padding: 15px 20px;
      position: sticky;
      top: 0;
      z-index: 100;
      border-bottom: 1px solid rgba(139, 92, 246, 0.3);
    }

    .arena-header-content {
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .arena-tema {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .arena-tema-icon {
      font-size: 1.5em;
    }

    .arena-tema-nome {
      font-weight: 700;
      font-size: 1.1em;
    }

    .arena-modo {
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 20px;
      background: rgba(139, 92, 246, 0.3);
      color: #a78bfa;
    }

    .arena-timer {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.1));
      border: 2px solid rgba(239, 68, 68, 0.5);
      border-radius: 14px;
    }

    .arena-timer.warning {
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .timer-icon {
      font-size: 1.2em;
    }

    .timer-value {
      font-size: 1.3em;
      font-weight: 800;
      color: #fff;
      font-variant-numeric: tabular-nums;
    }

    .arena-prize {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: linear-gradient(135deg, rgba(255, 181, 71, 0.2), rgba(255, 140, 66, 0.1));
      border: 1px solid rgba(255, 181, 71, 0.3);
      border-radius: 12px;
    }

    .arena-prize span:last-child {
      font-weight: 700;
      color: #ffb547;
    }

    /* Container Principal */
    .arena-container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Participantes Info */
    .participants-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      padding: 12px;
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .participants-count {
      font-weight: 700;
      color: #a78bfa;
    }

    /* Banner Eliminado (Sobreviv√™ncia) */
    .eliminated-banner {
      display: none;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.1));
      border: 2px solid rgba(239, 68, 68, 0.5);
      border-radius: 16px;
      padding: 25px;
      text-align: center;
      margin-bottom: 20px;
    }

    .eliminated-icon {
      font-size: 3em;
      margin-bottom: 10px;
    }

    .eliminated-title {
      font-size: 1.3em;
      font-weight: 700;
      color: #ef4444;
    }

    .eliminated-subtitle {
      color: #a9b5c6;
      margin-top: 5px;
    }

    /* Ranking Card */
    .ranking-card {
      background: linear-gradient(135deg, rgba(30, 41, 54, 0.9) 0%, rgba(24, 34, 46, 0.9) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .ranking-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .ranking-title h3 {
      font-size: 1em;
      font-weight: 700;
    }

    .ranking-live {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.8em;
      color: #10b981;
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .ranking-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .ranking-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      transition: all 0.3s ease;
    }

    .ranking-item.me {
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid rgba(139, 92, 246, 0.4);
    }

    .ranking-item.first {
      background: rgba(255, 181, 71, 0.15);
      border: 1px solid rgba(255, 181, 71, 0.3);
    }

    .ranking-item.second {
      background: rgba(192, 192, 192, 0.1);
      border: 1px solid rgba(192, 192, 192, 0.2);
    }

    .ranking-item.third {
      background: rgba(205, 127, 50, 0.1);
      border: 1px solid rgba(205, 127, 50, 0.2);
    }

    .ranking-position {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      font-weight: 800;
      font-size: 0.9em;
      background: rgba(255, 255, 255, 0.1);
    }

    .ranking-item.first .ranking-position {
      background: linear-gradient(135deg, #ffb547, #ff8c42);
      color: #0e141b;
    }

    .ranking-item.second .ranking-position {
      background: linear-gradient(135deg, #c0c0c0, #a0a0a0);
      color: #0e141b;
    }

    .ranking-item.third .ranking-position {
      background: linear-gradient(135deg, #cd7f32, #b8860b);
      color: #0e141b;
    }

    .ranking-avatar {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: linear-gradient(135deg, #8b5cf6, #6366f1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9em;
    }

    .ranking-info {
      flex: 1;
    }

    .ranking-name {
      font-weight: 600;
      font-size: 0.95em;
    }

    .ranking-stats {
      font-size: 0.8em;
      color: #a9b5c6;
    }

    .ranking-points {
      font-weight: 800;
      font-size: 1.1em;
      color: #ffb547;
    }

    /* My Status */
    .my-status-card {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(99, 102, 241, 0.1) 100%);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .my-status-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      margin-bottom: 15px;
    }

    .my-status-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .status-item {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }

    .status-value {
      font-size: 1.4em;
      font-weight: 800;
      color: #fff;
    }

    .status-value.pontos { color: #ffb547; }
    .status-value.acertos { color: #10b981; }
    .status-value.erros { color: #ef4444; }
    .status-value.streak { color: #8b5cf6; }

    .status-label {
      font-size: 0.75em;
      color: #a9b5c6;
      margin-top: 4px;
    }

    /* Vidas (Sobreviv√™ncia) */
    .vidas-container {
      display: none;
      justify-content: center;
      gap: 8px;
      margin-bottom: 15px;
    }

    .vida {
      font-size: 1.5em;
      transition: all 0.3s ease;
    }

    .vida.perdida {
      filter: grayscale(1);
      opacity: 0.3;
    }

    /* Question Section */
    .question-section {
      margin-top: 20px;
    }

    /* Waiting State */
    .waiting-state {
      text-align: center;
      padding: 40px 20px;
    }

    .waiting-icon {
      font-size: 4em;
      margin-bottom: 20px;
      animation: bounce 1s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .waiting-title {
      font-size: 1.3em;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .waiting-subtitle {
      color: #a9b5c6;
      margin-bottom: 25px;
    }

    .btn-start {
      padding: 16px 40px;
      font-size: 1.1em;
      font-weight: 700;
      background: linear-gradient(135deg, #8b5cf6, #6366f1);
      color: #fff;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      transition: all 0.3s ease;
    }

    .btn-start:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
    }

    .btn-start:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Question State */
    .question-state {
      display: none;
    }

    .question-card {
      background: linear-gradient(135deg, rgba(30, 41, 54, 0.95) 0%, rgba(24, 34, 46, 0.95) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 20px;
    }

    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .question-number {
      font-size: 0.9em;
      color: #a9b5c6;
    }

    .question-timer {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: rgba(239, 68, 68, 0.2);
      border-radius: 10px;
      font-weight: 700;
    }

    .question-timer.danger {
      background: rgba(239, 68, 68, 0.4);
      animation: pulse 0.5s infinite;
    }

    .question-text {
      font-size: 1.2em;
      font-weight: 600;
      line-height: 1.5;
      margin-bottom: 25px;
    }

    .options-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .option-btn {
      display: flex;
      align-items: center;
      gap: 15px;
      width: 100%;
      padding: 16px 20px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 14px;
      color: #fff;
      font-family: 'Poppins', sans-serif;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
    }

    .option-btn:hover:not(:disabled) {
      border-color: rgba(139, 92, 246, 0.5);
      background: rgba(139, 92, 246, 0.1);
      transform: translateX(5px);
    }

    .option-btn:disabled {
      cursor: not-allowed;
      opacity: 0.7;
    }

    .option-btn.correct {
      border-color: #10b981;
      background: rgba(16, 185, 129, 0.2);
    }

    .option-btn.wrong {
      border-color: #ef4444;
      background: rgba(239, 68, 68, 0.2);
    }

    .option-letter {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .option-text {
      flex: 1;
    }

    /* Ended State */
    .ended-state {
      display: none;
      text-align: center;
      padding: 40px 20px;
    }

    .ended-icon {
      font-size: 4em;
      margin-bottom: 20px;
    }

    .ended-title {
      font-size: 1.5em;
      font-weight: 800;
      margin-bottom: 10px;
    }

    .ended-subtitle {
      color: #a9b5c6;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: rgba(30, 41, 54, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 15px 25px;
      border-radius: 14px;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Loading */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      min-height: 60vh;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #8b5cf6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 20px;
      color: #a9b5c6;
    }

    /* Responsive */
    @media (max-width: 480px) {
      .arena-header-content {
        flex-wrap: wrap;
        gap: 10px;
      }

      .arena-timer {
        order: -1;
        width: 100%;
        justify-content: center;
      }

      .my-status-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .question-text {
        font-size: 1.1em;
      }
    }
  </style>
</head>

<body>

  <!-- Loading State -->
  <div id="loadingState" class="loading-container">
    <div class="spinner"></div>
    <p class="loading-text">Entrando no torneio...</p>
  </div>

  <!-- Main Arena (hidden until loaded) -->
  <div id="arenaMain" style="display: none;">
    
    <!-- Header da Arena -->
    <div class="arena-header">
      <div class="arena-header-content">
        <div class="arena-tema">
          <span class="arena-tema-icon" id="arenaTemaIcon">üèÜ</span>
          <span class="arena-tema-nome" id="arenaTema">Carregando...</span>
          <span class="arena-modo" id="arenaModo">Pontua√ß√£o</span>
        </div>
        
        <div class="arena-timer" id="arenaTimer">
          <span class="timer-icon">‚è±Ô∏è</span>
          <span class="timer-value" id="timerValue">00:00</span>
        </div>
        
        <div class="arena-prize">
          <span>üèÜ</span>
          <span id="arenaPrize">0</span>
        </div>
        
        <button onclick="sairArena()" style="padding:6px 14px; background:rgba(255,71,87,0.2); border:1px solid rgba(255,71,87,0.4); border-radius:8px; color:#ff6b81; font-family:'Poppins',sans-serif; font-size:0.75em; cursor:pointer;">
          Sair ‚úï
        </button>
      </div>
    </div>

    <!-- Container Principal -->
    <div class="arena-container">
      
      <!-- Barra de Participantes -->
      <div class="participants-bar">
        <span>üë•</span>
        <span class="participants-count" id="participantsCount">0 participantes</span>
      </div>

      <!-- Banner Eliminado (Sobreviv√™ncia) -->
      <div class="eliminated-banner" id="eliminatedBanner">
        <div class="eliminated-icon">üíÄ</div>
        <div class="eliminated-title">Voc√™ foi eliminado!</div>
        <div class="eliminated-subtitle">Aguarde o final para ver o resultado</div>
      </div>

      <!-- Ranking ao Vivo -->
      <div class="ranking-card">
        <div class="ranking-title">
          <h3>üèÖ Ranking ao Vivo</h3>
          <div class="ranking-live">
            <div class="live-dot"></div>
            <span>Atualizado</span>
          </div>
        </div>
        <div class="ranking-list" id="rankingList">
          <!-- Preenchido dinamicamente -->
        </div>
      </div>

      <!-- Meu Status -->
      <div class="my-status-card">
        <div class="my-status-title">
          <span>üìä</span>
          <span>Seu Desempenho</span>
        </div>
        
        <!-- Vidas (apenas sobreviv√™ncia) -->
        <div class="vidas-container" id="vidasContainer">
          <span class="vida" id="vida1">‚ù§Ô∏è</span>
          <span class="vida" id="vida2">‚ù§Ô∏è</span>
          <span class="vida" id="vida3">‚ù§Ô∏è</span>
        </div>
        
        <div class="my-status-grid">
          <div class="status-item">
            <div class="status-value pontos" id="myPoints">0</div>
            <div class="status-label">Pontos</div>
          </div>
          <div class="status-item">
            <div class="status-value acertos" id="myCorrect">0</div>
            <div class="status-label">Acertos</div>
          </div>
          <div class="status-item">
            <div class="status-value erros" id="myWrong">0</div>
            <div class="status-label">Erros</div>
          </div>
          <div class="status-item">
            <div class="status-value streak" id="myStreak">0</div>
            <div class="status-label">Streak</div>
          </div>
        </div>
      </div>

      <!-- Question Section -->
      <div class="question-section">
        
        <!-- Waiting State -->
        <div id="waitingState" class="waiting-state">
          <div class="waiting-icon">üéØ</div>
          <h2 class="waiting-title">Pronto para competir?</h2>
          <p class="waiting-subtitle">Responda o m√°ximo de perguntas corretamente!</p>
          <button class="btn-start" id="btnStart" onclick="carregarPergunta()">
            ‚ñ∂Ô∏è Come√ßar
          </button>
        </div>

        <!-- Question State -->
        <div id="questionState" class="question-state">
          <div class="question-card">
            <div class="question-header">
              <span class="question-number" id="questionNumber">Pergunta #1</span>
              <div class="question-timer" id="questionTimer">
                <span>‚è±Ô∏è</span>
                <span id="questionTimeLeft">10</span>
              </div>
            </div>
            
            <p class="question-text" id="questionText">Carregando pergunta...</p>
            
            <div class="options-list" id="optionsList">
              <!-- Preenchido dinamicamente -->
            </div>
          </div>
        </div>

        <!-- Ended State -->
        <div id="endedState" class="ended-state">
          <div class="ended-icon">üèÅ</div>
          <h2 class="ended-title">Torneio Finalizado!</h2>
          <p class="ended-subtitle">Calculando resultados...</p>
        </div>

      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
  <script src="js/firebase-init.js"></script>

  <script>
    // ===================================
    // üîß VARI√ÅVEIS GLOBAIS
    // ===================================
    const functions = firebase.functions();
    let currentUserId = null;
    let currentUserData = null;
    let torneioId = null;
    let torneioData = null;
    
    // Estado do jogo
    let gameState = {
      pontos: 0,
      acertos: 0,
      erros: 0,
      streak: 0,
      maxStreak: 0,
      vidas: 3,
      eliminado: false,
      perguntasRespondidas: [],
      perguntaAtual: null,
      totalPerguntas: 0
    };
    
    // Timers
    let mainTimerInterval = null;
    let questionTimerInterval = null;
    let questionTimeLeft = 10;
    let questionTimeTotal = 10; // configur√°vel pelo torneio
    
    // Listener do ranking
    let rankingUnsubscribe = null;
    
    // Guard contra finaliza√ß√£o dupla
    let finalizando = false;

    // ===================================
    // üöÄ INICIALIZA√á√ÉO
    // ===================================
    auth.onAuthStateChanged(async user => {
      if (!user) {
        window.location.href = 'index.html';
        return;
      }

      currentUserId = user.uid;
      
      try {
        const userDoc = await db.collection('usuarios').doc(user.uid).get();
        currentUserData = userDoc.data();
        
        // Pegar ID do torneio da URL
        const params = new URLSearchParams(window.location.search);
        torneioId = params.get('id');
        
        if (!torneioId) {
          showToast('‚ùå Torneio n√£o encontrado');
          setTimeout(() => window.location.href = 'torneios.html', 2000);
          return;
        }
        
        // Carregar torneio
        await carregarTorneio();
        
      } catch (error) {
        console.error("Erro ao inicializar:", error);
        showToast('‚ùå Erro ao carregar arena');
      }
    });

    // ===================================
    // üìä CARREGAR TORNEIO
    // ===================================
    async function carregarTorneio() {
      try {
        const doc = await db.collection('torneios').doc(torneioId).get();
        
        if (!doc.exists) {
          showToast('‚ùå Torneio n√£o encontrado');
          setTimeout(() => window.location.href = 'torneios.html', 2000);
          return;
        }
        
        torneioData = { id: doc.id, ...doc.data() };
        
        console.log("üìã Torneio carregado:", torneioData.nome);
        console.log("üìä Status:", torneioData.status);
        console.log("üë• Inscritos:", torneioData.inscritos);
        
        // Verificar se sou participante
        if (!torneioData.inscritos?.includes(currentUserId)) {
          showToast('‚ùå Voc√™ n√£o est√° inscrito neste torneio');
          setTimeout(() => window.location.href = 'torneios.html', 2000);
          return;
        }
        
        // Se j√° est√° finalizado, ir para resultado
        if (torneioData.status === 'finalizado') {
          console.log("üèÜ Torneio finalizado, redirecionando para resultado...");
          window.location.href = `resultado-torneio.html?id=${torneioId}`;
          return;
        }
        
        // Se N√ÉO est√° em andamento, verificar se pode iniciar
        if (torneioData.status !== 'em_andamento') {
          const dataInicio = torneioData.agendamento?.dataInicio?.toDate?.();
          const agora = new Date();
          
          console.log("‚è∞ Data in√≠cio:", dataInicio);
          console.log("‚è∞ Agora:", agora);
          console.log("‚è∞ J√° passou?", dataInicio && agora >= dataInicio);
          
          if (dataInicio && agora >= dataInicio) {
            // J√° passou da hora de in√≠cio, iniciar automaticamente!
            console.log("üöÄ Hora de in√≠cio chegou, iniciando torneio automaticamente...");
            showToast('üöÄ Iniciando torneio...');
            
            try {
              const duracaoMinutos = torneioData.config?.duracaoFase || 15;
              const dataFim = new Date(Date.now() + duracaoMinutos * 60 * 1000);
              
              console.log("‚è±Ô∏è Dura√ß√£o:", duracaoMinutos, "minutos");
              console.log("üèÅ Data fim:", dataFim);
              
              await db.collection('torneios').doc(torneioId).update({
                status: 'em_andamento',
                'agendamento.dataFim': firebase.firestore.Timestamp.fromDate(dataFim)
              });
              
              console.log("‚úÖ Status atualizado para em_andamento!");
              
              // Atualizar dados locais
              torneioData.status = 'em_andamento';
              torneioData.agendamento = torneioData.agendamento || {};
              torneioData.agendamento.dataFim = { toDate: () => dataFim };
              
            } catch (error) {
              console.error("‚ùå Erro ao iniciar torneio:", error);
              showToast('‚ö†Ô∏è Erro ao iniciar: ' + error.message);
              
              // Se erro de permiss√£o, pode ser que outro jogador j√° iniciou
              // Recarregar dados do torneio
              const torneioAtualizado = await db.collection('torneios').doc(torneioId).get();
              if (torneioAtualizado.exists) {
                torneioData = { id: torneioAtualizado.id, ...torneioAtualizado.data() };
                console.log("üìã Torneio recarregado, status:", torneioData.status);
                
                if (torneioData.status === 'em_andamento') {
                  console.log("‚úÖ Torneio j√° foi iniciado por outro jogador!");
                } else if (torneioData.status === 'finalizado') {
                  window.location.href = `resultado-torneio.html?id=${torneioId}`;
                  return;
                } else {
                  showToast('‚ùå N√£o foi poss√≠vel iniciar o torneio');
                  setTimeout(() => window.location.href = 'torneios.html', 2000);
                  return;
                }
              }
            }
          } else {
            // Ainda n√£o chegou a hora
            const minutosRestantes = dataInicio ? Math.ceil((dataInicio - agora) / 60000) : '?';
            showToast(`‚è≥ Torneio come√ßa em ${minutosRestantes} minutos`);
            setTimeout(() => window.location.href = 'torneios.html', 2000);
            return;
          }
        }
        
        // Verificar se agora est√° em andamento
        if (torneioData.status !== 'em_andamento') {
          console.log("‚ö†Ô∏è Status ainda n√£o √© em_andamento:", torneioData.status);
          showToast('‚è≥ Aguardando in√≠cio do torneio...');
          setTimeout(() => window.location.href = 'torneios.html', 2000);
          return;
        }
        
        console.log("‚úÖ Torneio em andamento, carregando arena...");
        
        // Carregar minha participa√ß√£o
        await carregarMinhaParticipacao();
        
        // Inicializar arena
        inicializarArena();
        
      } catch (error) {
        console.error("Erro ao carregar torneio:", error);
        showToast('‚ùå Erro ao carregar torneio');
      }
    }

    // ===================================
    // üë§ CARREGAR MINHA PARTICIPA√á√ÉO
    // ===================================
    async function carregarMinhaParticipacao() {
      try {
        const doc = await db.collection('torneios').doc(torneioId)
          .collection('participacoes').doc(currentUserId).get();
        
        if (doc.exists) {
          const data = doc.data();
          gameState.pontos = data.pontos || 0;
          gameState.acertos = data.acertos || 0;
          gameState.erros = data.erros || 0;
          gameState.streak = data.streakAtual || 0;
          gameState.maxStreak = data.streakMaximo || 0;
          gameState.vidas = data.vidasRestantes ?? 3;
          gameState.eliminado = !data.ativo;
          gameState.perguntasRespondidas = data.perguntasRespondidas || [];
          gameState.totalPerguntas = data.totalRespondidas || 0;
        } else {
          // Criar participa√ß√£o
          await db.collection('torneios').doc(torneioId)
            .collection('participacoes').doc(currentUserId).set({
              odId: currentUserId,
              odNome: currentUserData.usuarioUnico || 'An√¥nimo',
              foto: currentUserData.fotoPerfil || null,
              ativo: true,
              vidasRestantes: 3,
              pontos: 0,
              acertos: 0,
              erros: 0,
              totalRespondidas: 0,
              streakAtual: 0,
              streakMaximo: 0,
              perguntasRespondidas: [],
              ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
      } catch (error) {
        console.error("Erro ao carregar participa√ß√£o:", error);
      }
    }

    // ===================================
    // üéÆ INICIALIZAR ARENA
    // ===================================
    function inicializarArena() {
      // Esconder loading, mostrar arena
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('arenaMain').style.display = 'block';
      
      // Configurar header
      document.getElementById('arenaTema').textContent = torneioData.nome || 'Torneio';
      document.getElementById('arenaPrize').textContent = torneioData.prizePool || 0;
      
      // Modo
      const modoLabels = {
        pontuacao: 'Pontua√ß√£o',
        sobrevivencia: 'Sobreviv√™ncia'
      };
      document.getElementById('arenaModo').textContent = modoLabels[torneioData.config?.estilo] || 'Pontua√ß√£o';
      
      // Mostrar vidas se sobreviv√™ncia
      if (torneioData.config?.estilo === 'sobrevivencia') {
        document.getElementById('vidasContainer').style.display = 'flex';
        atualizarVidas();
      }
      
      // Timer da pergunta configur√°vel (padr√£o 10s)
      questionTimeTotal = torneioData.config?.tempoPergunta || 10;
      questionTimeLeft = questionTimeTotal;
      
      // Participantes
      document.getElementById('participantsCount').textContent = 
        `${torneioData.totalInscritos || torneioData.inscritos?.length || 0} participantes`;
      
      // Verificar se estou eliminado
      if (gameState.eliminado) {
        document.getElementById('eliminatedBanner').style.display = 'block';
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnStart').textContent = 'üíÄ Eliminado';
      }
      
      // Atualizar UI inicial
      atualizarMeuStatus();
      
      // Iniciar timer do torneio
      iniciarTimerPrincipal();
      
      // Listener do ranking ao vivo
      iniciarListenerRanking();
    }

    // ===================================
    // ‚è±Ô∏è TIMER PRINCIPAL
    // ===================================
    function iniciarTimerPrincipal() {
      console.log("‚è±Ô∏è Iniciando timer principal...");
      console.log("üìÖ Dados agendamento:", torneioData.agendamento);
      
      let dataFim;
      
      // Tentar pegar dataFim salva
      if (torneioData.agendamento?.dataFim?.toDate) {
        dataFim = torneioData.agendamento.dataFim.toDate();
        console.log("üìÖ Usando dataFim salva:", dataFim);
      } else if (torneioData.agendamento?.dataFim) {
        // Pode ser um objeto com fun√ß√£o toDate que criamos localmente
        dataFim = typeof torneioData.agendamento.dataFim.toDate === 'function' 
                  ? torneioData.agendamento.dataFim.toDate()
                  : new Date(torneioData.agendamento.dataFim);
        console.log("üìÖ Usando dataFim convertida:", dataFim);
      } else {
        // Calcular baseado na dura√ß√£o
        const duracaoMinutos = torneioData.config?.duracaoFase || 15;
        dataFim = new Date(Date.now() + duracaoMinutos * 60 * 1000);
        console.log("üìÖ Calculando dataFim:", dataFim, "(dura√ß√£o:", duracaoMinutos, "min)");
      }
      
      console.log("üèÅ Timer terminar√° em:", dataFim);
      
      function atualizar() {
        const agora = new Date();
        const diff = dataFim - agora;
        
        if (diff <= 0) {
          console.log("üèÅ TEMPO ESGOTADO! Chamando finalizarTorneio()...");
          clearInterval(mainTimerInterval);
          document.getElementById('timerValue').textContent = '00:00';
          finalizarTorneio();
          return;
        }
        
        const minutos = Math.floor(diff / 60000);
        const segundos = Math.floor((diff % 60000) / 1000);
        document.getElementById('timerValue').textContent = 
          `${String(minutos).padStart(2, '0')}:${String(segundos).padStart(2, '0')}`;
        
        // Warning se menos de 1 minuto
        if (diff < 60000) {
          document.getElementById('arenaTimer').classList.add('warning');
        }
      }
      
      atualizar();
      mainTimerInterval = setInterval(atualizar, 1000);
    }

    // ===================================
    // üèÖ LISTENER RANKING AO VIVO
    // ===================================
    function iniciarListenerRanking() {
      rankingUnsubscribe = db.collection('torneios').doc(torneioId)
        .collection('participacoes')
        .orderBy('pontos', 'desc')
        .limit(20)
        .onSnapshot(snapshot => {
          const ranking = [];
          snapshot.forEach(doc => {
            ranking.push({ odId: doc.id, ...doc.data() });
          });
          renderizarRanking(ranking);
        });
      
      // Listener do status do torneio (admin pode finalizar a qualquer momento)
      db.collection('torneios').doc(torneioId).onSnapshot(doc => {
        if (!doc.exists) return;
        const data = doc.data();
        if (data.status === 'finalizado' && !finalizando) {
          finalizando = true;
          clearInterval(mainTimerInterval);
          clearInterval(questionTimerInterval);
          showToast('üèÜ Torneio finalizado pelo administrador!');
          setTimeout(() => {
            window.location.href = `resultado-torneio.html?id=${torneioId}`;
          }, 2000);
        }
      });
    }

    // ===================================
    // üìä RENDERIZAR RANKING
    // ===================================
    function renderizarRanking(ranking) {
      const container = document.getElementById('rankingList');
      
      if (ranking.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #a9b5c6;">Aguardando participantes...</p>';
        return;
      }
      
      container.innerHTML = ranking.map((player, index) => {
        const isMe = player.odId === currentUserId;
        const positionClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
        const meClass = isMe ? 'me' : '';
        const letra = (player.odNome || '?').charAt(0).toUpperCase();
        
        const fotoHtml = player.foto 
          ? `<div class="ranking-avatar" style="background-image: url('${player.foto}'); background-size: cover;"></div>`
          : `<div class="ranking-avatar">${letra}</div>`;
        
        return `
          <div class="ranking-item ${positionClass} ${meClass}">
            <div class="ranking-position">${index + 1}</div>
            ${fotoHtml}
            <div class="ranking-info">
              <div class="ranking-name">${player.odNome || 'An√¥nimo'} ${isMe ? '(voc√™)' : ''}</div>
              <div class="ranking-stats">${player.acertos || 0} acertos ‚Ä¢ ${player.erros || 0} erros</div>
            </div>
            <div class="ranking-points">${player.pontos || 0}</div>
          </div>
        `;
      }).join('');
    }

    // ===================================
    // üìù CARREGAR PERGUNTA
    // ===================================
    async function carregarPergunta() {
      if (gameState.eliminado) {
        showToast('üíÄ Voc√™ foi eliminado!');
        return;
      }
      
      const btn = document.getElementById('btnStart');
      btn.disabled = true;
      btn.textContent = '‚è≥ Carregando...';
      
      try {
        let perguntas = [];
        
        // Buscar perguntas do tema do torneio
        const tema = torneioData.tema;
        
        // Gerar ID aleat√≥rio para offset (aleatoriedade real no Firestore)
        const randomId = db.collection('_').doc().id;
        
        if (tema?.tipo === 'time' && tema.id) {
          // Buscar com offset aleat√≥rio (metade >= randomId, metade < randomId)
          const snap1 = await db.collection('perguntas')
            .where('timeId', '==', tema.id)
            .where(firebase.firestore.FieldPath.documentId(), '>=', randomId)
            .limit(30)
            .get();
          
          snap1.forEach(doc => {
            if (!gameState.perguntasRespondidas.includes(doc.id)) {
              perguntas.push({ id: doc.id, ...doc.data() });
            }
          });
          
          // Se poucos resultados, buscar do outro lado
          if (perguntas.length < 5) {
            const snap2 = await db.collection('perguntas')
              .where('timeId', '==', tema.id)
              .where(firebase.firestore.FieldPath.documentId(), '<', randomId)
              .limit(30)
              .get();
            
            snap2.forEach(doc => {
              if (!gameState.perguntasRespondidas.includes(doc.id) && 
                  !perguntas.find(p => p.id === doc.id)) {
                perguntas.push({ id: doc.id, ...doc.data() });
              }
            });
          }
          
        } else if (tema?.tipo === 'campeonato' && tema.id) {
          const snap1 = await db.collection('perguntas')
            .where('campeonatoId', '==', tema.id)
            .where(firebase.firestore.FieldPath.documentId(), '>=', randomId)
            .limit(30)
            .get();
          
          snap1.forEach(doc => {
            if (!gameState.perguntasRespondidas.includes(doc.id)) {
              perguntas.push({ id: doc.id, ...doc.data() });
            }
          });
          
          if (perguntas.length < 5) {
            const snap2 = await db.collection('perguntas')
              .where('campeonatoId', '==', tema.id)
              .where(firebase.firestore.FieldPath.documentId(), '<', randomId)
              .limit(30)
              .get();
            
            snap2.forEach(doc => {
              if (!gameState.perguntasRespondidas.includes(doc.id) &&
                  !perguntas.find(p => p.id === doc.id)) {
                perguntas.push({ id: doc.id, ...doc.data() });
              }
            });
          }
        }
        
        // Se n√£o encontrou do tema, busca gerais com offset aleat√≥rio
        if (perguntas.length === 0) {
          const snap1 = await db.collection('perguntas')
            .where(firebase.firestore.FieldPath.documentId(), '>=', randomId)
            .limit(50)
            .get();
          
          snap1.forEach(doc => {
            if (!gameState.perguntasRespondidas.includes(doc.id)) {
              perguntas.push({ id: doc.id, ...doc.data() });
            }
          });
          
          if (perguntas.length < 10) {
            const snap2 = await db.collection('perguntas')
              .where(firebase.firestore.FieldPath.documentId(), '<', randomId)
              .limit(50)
              .get();
            
            snap2.forEach(doc => {
              if (!gameState.perguntasRespondidas.includes(doc.id) &&
                  !perguntas.find(p => p.id === doc.id)) {
                perguntas.push({ id: doc.id, ...doc.data() });
              }
            });
          }
        }
        
        if (perguntas.length === 0) {
          showToast('üéâ Voc√™ respondeu todas as perguntas!');
          btn.textContent = '‚úÖ Todas respondidas';
          return;
        }
        
        // Fisher-Yates shuffle para aleatoriedade real
        for (let i = perguntas.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [perguntas[i], perguntas[j]] = [perguntas[j], perguntas[i]];
        }
        
        // Pegar a primeira do pool embaralhado
        const pergunta = perguntas[0];
        gameState.perguntaAtual = pergunta;
        gameState.totalPerguntas++;
        
        mostrarPergunta(pergunta);
        
      } catch (error) {
        console.error("Erro ao carregar pergunta:", error);
        showToast('‚ùå Erro ao carregar pergunta');
        btn.disabled = false;
        btn.textContent = '‚ñ∂Ô∏è Pr√≥xima Pergunta';
      }
    }

    // ===================================
    // üìù MOSTRAR PERGUNTA
    // ===================================
    function mostrarPergunta(pergunta) {
      document.getElementById('waitingState').style.display = 'none';
      document.getElementById('questionState').style.display = 'block';
      
      document.getElementById('questionNumber').textContent = `Pergunta #${gameState.totalPerguntas}`;
      
      const textoPergunta = pergunta.pergunta || pergunta.texto || pergunta.question || '';
      document.getElementById('questionText').textContent = textoPergunta;
      
      // Alternativas
      let opcoes = [];
      const altField = pergunta.alternativas || pergunta.opcoes || pergunta.respostas;
      
      if (altField) {
        if (Array.isArray(altField)) {
          opcoes = altField;
        } else if (typeof altField === 'object') {
          const keys = Object.keys(altField).sort();
          opcoes = keys.map(k => altField[k]);
        }
      }
      
      if (opcoes.length === 0 && (pergunta.opcaoA || pergunta.opcao_a || pergunta.alternativaA)) {
        opcoes = [
          pergunta.opcaoA || pergunta.opcao_a || pergunta.alternativaA || '',
          pergunta.opcaoB || pergunta.opcao_b || pergunta.alternativaB || '',
          pergunta.opcaoC || pergunta.opcao_c || pergunta.alternativaC || '',
          pergunta.opcaoD || pergunta.opcao_d || pergunta.alternativaD || ''
        ].filter(o => o);
      }
      
      if (opcoes.length === 0 && (pergunta.a || pergunta.A)) {
        opcoes = [
          pergunta.a || pergunta.A || '',
          pergunta.b || pergunta.B || '',
          pergunta.c || pergunta.C || '',
          pergunta.d || pergunta.D || ''
        ].filter(o => o);
      }
      
      const letras = ['A', 'B', 'C', 'D'];
      
      // Embaralhar op√ß√µes
      const opcoesEmbaralhadas = [...opcoes].sort(() => Math.random() - 0.5);
      
      document.getElementById('optionsList').innerHTML = opcoesEmbaralhadas.map((opcao, i) => {
        const textoOpcao = typeof opcao === 'string' ? opcao : (opcao.texto || opcao.text || opcao.label || String(opcao));
        return `
          <button class="option-btn" onclick="responderPergunta('${letras[i]}')" data-letra="${letras[i]}">
            <span class="option-letter">${letras[i]}</span>
            <span class="option-text">${textoOpcao}</span>
          </button>
        `;
      }).join('');
      
      // Guardar mapeamento da resposta correta
      const respostaOriginal = pergunta.resposta || pergunta.correta || pergunta.alternativaCorreta;
      const indiceOriginal = letras.indexOf(respostaOriginal?.toUpperCase());
      const opcaoCorreta = indiceOriginal >= 0 ? opcoes[indiceOriginal] : null;
      const novoIndice = opcaoCorreta ? opcoesEmbaralhadas.indexOf(opcaoCorreta) : -1;
      gameState.respostaCorreta = novoIndice >= 0 ? letras[novoIndice] : respostaOriginal;
      
      iniciarTimerPergunta();
    }

    // ===================================
    // ‚è±Ô∏è TIMER DA PERGUNTA
    // ===================================
    function iniciarTimerPergunta() {
      questionTimeLeft = questionTimeTotal;
      atualizarTimerPergunta();
      
      questionTimerInterval = setInterval(() => {
        questionTimeLeft--;
        atualizarTimerPergunta();
        
        if (questionTimeLeft <= 0) {
          clearInterval(questionTimerInterval);
          tempoEsgotado();
        }
      }, 1000);
    }

    function atualizarTimerPergunta() {
      document.getElementById('questionTimeLeft').textContent = questionTimeLeft;
      
      if (questionTimeLeft <= 3) {
        document.getElementById('questionTimer').classList.add('danger');
      } else {
        document.getElementById('questionTimer').classList.remove('danger');
      }
    }

    // ===================================
    // ‚è∞ TEMPO ESGOTADO
    // ===================================
    function tempoEsgotado() {
      processarResposta(null, false);
    }

    // ===================================
    // ‚úÖ RESPONDER PERGUNTA
    // ===================================
    async function responderPergunta(letra) {
      clearInterval(questionTimerInterval);
      
      // Desabilitar bot√µes
      document.querySelectorAll('.option-btn').forEach(btn => btn.disabled = true);
      
      const respostaCorreta = gameState.respostaCorreta?.toUpperCase();
      const acertou = letra.toUpperCase() === respostaCorreta;
      
      // Marcar visualmente
      document.querySelectorAll('.option-btn').forEach(btn => {
        const btnLetra = btn.dataset.letra;
        if (btnLetra === respostaCorreta) {
          btn.classList.add('correct');
        } else if (btnLetra === letra && !acertou) {
          btn.classList.add('wrong');
        }
      });
      
      await processarResposta(letra, acertou);
    }

    // ===================================
    // üìä PROCESSAR RESPOSTA
    // ===================================
    async function processarResposta(letra, acertou) {
      const pergunta = gameState.perguntaAtual;
      
      if (acertou) {
        // Acertou
        const pontosBase = 10;
        const bonusStreak = gameState.streak * 2;
        const bonusTempo = questionTimeLeft;
        const pontosGanhos = pontosBase + bonusStreak + bonusTempo;
        
        gameState.pontos += pontosGanhos;
        gameState.acertos++;
        gameState.streak++;
        gameState.maxStreak = Math.max(gameState.maxStreak, gameState.streak);
        
        let detalhes = `‚úÖ +${pontosGanhos} pts`;
        if (bonusStreak > 0) detalhes += ` (üî•${gameState.streak})`;
        if (bonusTempo > 5) detalhes += ` (‚ö°r√°pido!)`;
        showToast(detalhes);
        
      } else {
        // Errou ou tempo esgotado
        gameState.erros++;
        gameState.streak = 0;
        
        // Sobreviv√™ncia: perder vida
        if (torneioData.config?.estilo === 'sobrevivencia') {
          gameState.vidas--;
          atualizarVidas();
          
          if (gameState.vidas <= 0) {
            gameState.eliminado = true;
            document.getElementById('eliminatedBanner').style.display = 'block';
            showToast('üíÄ Voc√™ foi eliminado!');
          }
        }
        
        if (!letra) {
          showToast('‚è∞ Tempo esgotado!');
        } else {
          showToast('‚ùå Resposta incorreta!');
        }
      }
      
      // Adicionar pergunta √†s respondidas
      gameState.perguntasRespondidas.push(pergunta.id);
      
      // Atualizar no banco
      try {
        await db.collection('torneios').doc(torneioId)
          .collection('participacoes').doc(currentUserId).update({
            pontos: gameState.pontos,
            acertos: gameState.acertos,
            erros: gameState.erros,
            streakAtual: gameState.streak,
            streakMaximo: gameState.maxStreak,
            vidasRestantes: gameState.vidas,
            ativo: !gameState.eliminado,
            totalRespondidas: gameState.totalPerguntas,
            perguntasRespondidas: firebase.firestore.FieldValue.arrayUnion(pergunta.id),
            ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        // Registrar resposta
        await db.collection('torneios').doc(torneioId)
          .collection('respostas').add({
            odId: currentUserId,
            perguntaId: pergunta.id,
            resposta: letra,
            correta: acertou,
            tempoResposta: questionTimeTotal - questionTimeLeft,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
          
      } catch (error) {
        console.error("Erro ao salvar resposta:", error);
      }
      
      // Atualizar UI
      atualizarMeuStatus();
      
      // Pr√≥xima pergunta automaticamente ap√≥s 1.5s
      setTimeout(() => {
        if (!gameState.eliminado) {
          document.getElementById('questionState').style.display = 'none';
          document.getElementById('waitingState').style.display = 'block';
          
          const btn = document.getElementById('btnStart');
          btn.disabled = false;
          btn.textContent = '‚ñ∂Ô∏è Pr√≥xima Pergunta';
          
          // Auto-carregar pr√≥xima pergunta
          carregarPergunta();
        }
      }, 1500);
    }

    // ===================================
    // üìä ATUALIZAR MEU STATUS
    // ===================================
    function atualizarMeuStatus() {
      document.getElementById('myPoints').textContent = gameState.pontos;
      document.getElementById('myCorrect').textContent = gameState.acertos;
      document.getElementById('myWrong').textContent = gameState.erros;
      document.getElementById('myStreak').textContent = gameState.streak;
    }

    // ===================================
    // ‚ù§Ô∏è ATUALIZAR VIDAS
    // ===================================
    function atualizarVidas() {
      for (let i = 1; i <= 3; i++) {
        const vida = document.getElementById(`vida${i}`);
        if (i > gameState.vidas) {
          vida.classList.add('perdida');
        }
      }
    }

    // ===================================
    // üèÅ FINALIZAR TORNEIO (AUTOM√ÅTICO)
    // ===================================
    async function finalizarTorneio() {
      if (finalizando) return; // Guard contra dupla finaliza√ß√£o
      finalizando = true;
      
      console.log("üèÅ Iniciando finaliza√ß√£o do torneio...");
      
      // Parar listeners e timers
      if (rankingUnsubscribe) rankingUnsubscribe();
      clearInterval(mainTimerInterval);
      clearInterval(questionTimerInterval);
      
      // Esconder todos os estados e mostrar tela final
      const waitingState = document.getElementById('waitingState');
      const questionState = document.getElementById('questionState');
      const endedState = document.getElementById('endedState');
      
      if (waitingState) waitingState.style.display = 'none';
      if (questionState) questionState.style.display = 'none';
      if (endedState) endedState.style.display = 'block';
      
      const timerValue = document.getElementById('timerValue');
      if (timerValue) timerValue.textContent = '00:00';
      
      // Atualizar texto do estado final
      const endedTitle = document.querySelector('.ended-title');
      const endedSubtitle = document.querySelector('.ended-subtitle');
      if (endedTitle) endedTitle.textContent = 'Torneio Finalizado!';
      if (endedSubtitle) endedSubtitle.textContent = 'Calculando resultados...';
      
      showToast('üèÅ Calculando resultado...');
      
      try {
        // Verificar se j√° foi finalizado PRIMEIRO
        console.log("üìã Verificando status atual...");
        const torneioDoc = await db.collection('torneios').doc(torneioId).get();
        const torneioAtual = torneioDoc.data();
        
        console.log("Status atual:", torneioAtual.status);
        
        if (torneioAtual.status === 'finalizado') {
          console.log("‚úÖ Torneio j√° finalizado, redirecionando...");
          showToast('üèÜ Torneio finalizado!');
          setTimeout(() => {
            window.location.href = `resultado-torneio.html?id=${torneioId}`;
          }, 1500);
          return;
        }
        
        // Buscar ranking final
        console.log("üìä Buscando ranking...");
        const participacoesSnap = await db.collection('torneios').doc(torneioId)
          .collection('participacoes').orderBy('pontos', 'desc').get();
        
        let ranking = [];
        participacoesSnap.forEach(doc => {
          ranking.push({ odId: doc.id, ...doc.data() });
        });
        
        console.log("Ranking encontrado:", ranking.length, "participantes");
        console.log("Ranking:", ranking);
        
        // Calcular pr√™mios
        const prizePool = torneioAtual.prizePool || 0;
        const distribuicao = torneioAtual.config?.distribuicaoPremio || { primeiro: 50, segundo: 30, terceiro: 20 };
        
        const premio1 = Math.floor(prizePool * distribuicao.primeiro / 100);
        const premio2 = Math.floor(prizePool * distribuicao.segundo / 100);
        const premio3 = Math.floor(prizePool * distribuicao.terceiro / 100);
        
        console.log("üí∞ Prize Pool:", prizePool, "| Pr√™mios:", premio1, premio2, premio3);
        
        // Resultado final
        let resultado = {
          primeiro: ranking[0] ? { odId: ranking[0].odId, odNome: ranking[0].odNome, pontos: ranking[0].pontos, premio: premio1 } : null,
          segundo: ranking[1] ? { odId: ranking[1].odId, odNome: ranking[1].odNome, pontos: ranking[1].pontos, premio: premio2 } : null,
          terceiro: ranking[2] ? { odId: ranking[2].odId, odNome: ranking[2].odNome, pontos: ranking[2].pontos, premio: premio3 } : null,
          ranking: ranking.map((r, i) => ({
            posicao: i + 1,
            odId: r.odId,
            odNome: r.odNome,
            pontos: r.pontos || 0,
            acertos: r.acertos || 0,
            erros: r.erros || 0
          }))
        };
        
        console.log("üìù Resultado calculado:", resultado);
        
        // ‚úÖ Tentar Cloud Function primeiro, fallback client-side
        let finalizadoPorFn = false;
        try {
          const finalizarTorneioFn = functions.httpsCallable('finalizarTorneio');
          const resultadoFn = await finalizarTorneioFn({ torneioId: torneioId });
          if (resultadoFn.data?.resultado) {
            resultado = resultadoFn.data.resultado;
          }
          finalizadoPorFn = true;
          console.log("‚úÖ Finalizado via Cloud Function");
        } catch (fnError) {
          console.warn("‚ö†Ô∏è Cloud Function falhou, finalizando client-side:", fnError.message);
          
          // Fallback: finalizar diretamente (mesmo l√≥gica do admin)
          try {
            // Distribuir pr√™mios
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            const premiosList = [premio1, premio2, premio3];
            const statsKeys = ['vitorias', 'top3', 'top3'];
            
            for (let i = 0; i < 3 && i < ranking.length; i++) {
              if (premiosList[i] > 0) {
                const uid = ranking[i].odId;
                const stats = { 
                  creditos: firebase.firestore.FieldValue.increment(premiosList[i]),
                  'torneios.creditosGanhos': firebase.firestore.FieldValue.increment(premiosList[i]),
                  'torneios.totalTorneios': firebase.firestore.FieldValue.increment(1)
                };
                stats[`torneios.${statsKeys[i]}`] = firebase.firestore.FieldValue.increment(1);
                
                await db.collection('usuarios').doc(uid).update(stats);
                await db.collection('transacoes').add({
                  usuarioId: uid, tipo: 'credito', valor: premiosList[i],
                  descricao: `${medals[i]} ${i+1}¬∫ lugar no torneio ${torneioAtual.nome} (+${premiosList[i]} cr√©ditos)`,
                  torneioId: torneioId, data: firebase.firestore.FieldValue.serverTimestamp()
                });
                await db.collection('usuarios').doc(uid).collection('extrato').add({
                  tipo: 'entrada', valor: premiosList[i],
                  descricao: `${medals[i]} ${i+1}¬∫ lugar: ${torneioAtual.nome}`,
                  data: firebase.firestore.FieldValue.serverTimestamp()
                });
              }
            }
            
            // Demais participantes
            for (let i = 3; i < ranking.length; i++) {
              try {
                await db.collection('usuarios').doc(ranking[i].odId).update({
                  'torneios.totalTorneios': firebase.firestore.FieldValue.increment(1)
                });
              } catch (e) {}
            }
            
            // Marcar torneio como finalizado
            await db.collection('torneios').doc(torneioId).update({
              status: 'finalizado',
              resultado: resultado,
              dataFinalizacao: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            finalizadoPorFn = true; // mark as done
            console.log("‚úÖ Finalizado via fallback client-side");
            
            // Notificar top 3
            try {
              const medals = ['ü•á', 'ü•à', 'ü•â'];
              const premios = [premio1, premio2, premio3];
              for (let i = 0; i < 3 && i < ranking.length; i++) {
                if (premios[i] > 0) {
                  await db.collection('notificacoes').add({
                    para: ranking[i].odId,
                    tipo: 'torneio_resultado',
                    titulo: `${medals[i]} ${i+1}¬∫ lugar no torneio!`,
                    mensagem: `Voc√™ ficou em ${i+1}¬∫ no "${torneioAtual.nome}" e ganhou ${premios[i]} cr√©ditos!`,
                    link: `resultado-torneio.html?id=${torneioId}`,
                    lida: false,
                    data: firebase.firestore.FieldValue.serverTimestamp()
                  });
                }
              }
            } catch (ne) { console.warn('Notif:', ne); }
          } catch (fallbackErr) {
            console.error("‚ùå Fallback tamb√©m falhou:", fallbackErr);
          }
        }
        
        showToast(`üèÜ ${ranking[0]?.odNome || 'Torneio'} venceu!`);
        
        // Redirecionar ap√≥s 2s
        console.log("üîÑ Redirecionando para resultado em 2s...");
        setTimeout(() => {
          window.location.href = `resultado-torneio.html?id=${torneioId}`;
        }, 2000);
        
      } catch (error) {
        console.error("‚ùå Erro geral ao finalizar torneio:", error);
        showToast('‚ö†Ô∏è Erro: ' + error.message);
        
        // Mesmo com erro, tentar redirecionar ap√≥s 3s
        setTimeout(() => {
          window.location.href = `resultado-torneio.html?id=${torneioId}`;
        }, 3000);
      }
    }

    // ===================================
    // üçû TOAST
    // ===================================
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    // ===================================
    // üö™ SAIR DA ARENA
    // ===================================
    function sairArena() {
      if (gameState.totalPerguntas > 0) {
        if (!confirm('Sair da arena? Seus pontos j√° foram salvos, voc√™ pode voltar depois.')) return;
      }
      if (rankingUnsubscribe) rankingUnsubscribe();
      clearInterval(mainTimerInterval);
      clearInterval(questionTimerInterval);
      window.location.href = 'torneios.html';
    }

    // ===================================
    // üßπ CLEANUP
    // ===================================
    window.addEventListener('beforeunload', () => {
      if (rankingUnsubscribe) rankingUnsubscribe();
      clearInterval(mainTimerInterval);
      clearInterval(questionTimerInterval);
    });

    console.log("‚úÖ Arena Torneio v1.0 carregado");
  </script>

</body>
</html>
