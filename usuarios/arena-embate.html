<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arena - Yellup</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0e141b 0%, #1a2332 100%);
      color: #e7eef7;
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Header da Arena */
    .arena-header {
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4));
      backdrop-filter: blur(20px);
      padding: 15px 20px;
      position: sticky;
      top: 0;
      z-index: 100;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .arena-header-content {
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .arena-tema {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .arena-tema-icon {
      font-size: 1.5em;
    }

    .arena-tema-nome {
      font-weight: 700;
      font-size: 1.1em;
    }

    .arena-modo {
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 20px;
      background: rgba(255, 181, 71, 0.2);
      color: #ffb547;
    }

    .arena-timer {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.1));
      border: 2px solid rgba(239, 68, 68, 0.5);
      border-radius: 14px;
    }

    .arena-timer.warning {
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .timer-icon {
      font-size: 1.2em;
    }

    .timer-value {
      font-size: 1.3em;
      font-weight: 800;
      color: #fff;
      font-variant-numeric: tabular-nums;
    }

    .arena-prize {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: rgba(255, 181, 71, 0.15);
      border-radius: 20px;
      font-weight: 700;
      color: #ffb547;
    }

    /* Container Principal */
    .arena-container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      padding-bottom: 100px;
    }

    /* Ranking Card */
    .ranking-card {
      background: linear-gradient(135deg, rgba(30, 41, 54, 0.95) 0%, rgba(24, 34, 46, 0.95) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .ranking-title {
      font-size: 0.85em;
      color: #a9b5c6;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ranking-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .ranking-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      transition: all 0.3s ease;
    }

    .ranking-item.me {
      background: rgba(255, 181, 71, 0.15);
      border: 2px solid rgba(255, 181, 71, 0.4);
    }

    .ranking-item.eliminated {
      opacity: 0.5;
      text-decoration: line-through;
    }

    .ranking-position {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 0.85em;
    }

    .ranking-position.gold {
      background: linear-gradient(135deg, #ffd700, #ffaa00);
      color: #0e141b;
    }

    .ranking-position.silver {
      background: linear-gradient(135deg, #c0c0c0, #a0a0a0);
      color: #0e141b;
    }

    .ranking-position.bronze {
      background: linear-gradient(135deg, #cd7f32, #a56527);
      color: #fff;
    }

    .ranking-position.normal {
      background: rgba(255, 255, 255, 0.1);
      color: #a9b5c6;
    }

    .ranking-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ffb547, #ff8c42);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: #0e141b;
      font-size: 0.9em;
    }

    .ranking-info {
      flex: 1;
    }

    .ranking-name {
      font-weight: 600;
      font-size: 0.95em;
    }

    .ranking-stats {
      font-size: 0.75em;
      color: #a9b5c6;
    }

    .ranking-points {
      font-size: 1.1em;
      font-weight: 800;
      color: #ffb547;
    }

    .ranking-lives {
      display: flex;
      gap: 2px;
      margin-left: 10px;
    }

    /* Meu Status Card */
    .my-status-card {
      background: linear-gradient(135deg, rgba(255, 181, 71, 0.1), rgba(255, 140, 66, 0.05));
      border: 2px solid rgba(255, 181, 71, 0.3);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .my-status-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      text-align: center;
    }

    .my-status-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .my-status-value {
      font-size: 1.8em;
      font-weight: 800;
      color: #ffb547;
    }

    .my-status-value.green { color: #10b981; }
    .my-status-value.red { color: #ef4444; }

    .my-status-label {
      font-size: 0.7em;
      color: #a9b5c6;
      text-transform: uppercase;
    }

    .my-lives {
      display: flex;
      gap: 5px;
      font-size: 1.5em;
    }

    /* √Årea de Perguntas */
    .question-area {
      background: linear-gradient(135deg, rgba(30, 41, 54, 0.95) 0%, rgba(24, 34, 46, 0.95) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    /* Estado: Aguardando */
    .waiting-state {
      padding: 50px 30px;
      text-align: center;
    }

    .waiting-icon {
      font-size: 4em;
      margin-bottom: 20px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .waiting-title {
      font-size: 1.3em;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .waiting-subtitle {
      color: #a9b5c6;
      margin-bottom: 25px;
    }

    .btn-next-question {
      padding: 18px 40px;
      background: linear-gradient(135deg, #ffb547, #ff8c42);
      border: none;
      border-radius: 14px;
      color: #0e141b;
      font-family: 'Poppins', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-next-question:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 181, 71, 0.4);
    }

    .btn-next-question:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Estado: Pergunta */
    .question-state {
      display: none;
    }

    .question-timer-bar {
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
    }

    .question-timer-fill {
      height: 100%;
      background: linear-gradient(90deg, #10b981, #059669);
      transition: width 0.1s linear;
    }

    .question-timer-fill.warning {
      background: linear-gradient(90deg, #f59e0b, #d97706);
    }

    .question-timer-fill.danger {
      background: linear-gradient(90deg, #ef4444, #dc2626);
    }

    .question-header {
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .question-number {
      font-size: 0.85em;
      color: #a9b5c6;
    }

    .question-timer-text {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 1.2em;
      font-weight: 700;
    }

    .question-timer-text.warning { color: #f59e0b; }
    .question-timer-text.danger { color: #ef4444; animation: pulse 0.5s infinite; }

    .question-content {
      padding: 0 20px 20px;
    }

    .question-text {
      font-size: 1.2em;
      font-weight: 600;
      line-height: 1.5;
      margin-bottom: 25px;
    }

    .options-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .option-btn {
      width: 100%;
      padding: 18px 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 14px;
      color: #e7eef7;
      font-family: 'Poppins', sans-serif;
      font-size: 1em;
      text-align: left;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .option-btn:hover:not(:disabled) {
      border-color: rgba(255, 181, 71, 0.5);
      background: rgba(255, 181, 71, 0.1);
    }

    .option-btn:disabled {
      cursor: not-allowed;
    }

    .option-btn.selected {
      border-color: #ffb547;
      background: rgba(255, 181, 71, 0.2);
    }

    .option-btn.correct {
      border-color: #10b981;
      background: rgba(16, 185, 129, 0.2);
    }

    .option-btn.wrong {
      border-color: #ef4444;
      background: rgba(239, 68, 68, 0.2);
    }

    .option-letter {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      flex-shrink: 0;
    }

    .option-btn.correct .option-letter {
      background: #10b981;
      color: #fff;
    }

    .option-btn.wrong .option-letter {
      background: #ef4444;
      color: #fff;
    }

    .option-text {
      flex: 1;
    }

    /* Feedback */
    .feedback-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .feedback-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .feedback-card {
      background: linear-gradient(135deg, rgba(30, 41, 54, 0.98) 0%, rgba(24, 34, 46, 0.98) 100%);
      border-radius: 24px;
      padding: 40px;
      text-align: center;
      transform: scale(0.8);
      transition: transform 0.3s ease;
      max-width: 90%;
    }

    .feedback-overlay.show .feedback-card {
      transform: scale(1);
    }

    .feedback-icon {
      font-size: 5em;
      margin-bottom: 20px;
    }

    .feedback-title {
      font-size: 1.5em;
      font-weight: 800;
      margin-bottom: 10px;
    }

    .feedback-title.correct { color: #10b981; }
    .feedback-title.wrong { color: #ef4444; }
    .feedback-title.timeout { color: #f59e0b; }

    .feedback-points {
      font-size: 2em;
      font-weight: 800;
      color: #ffb547;
      margin-bottom: 10px;
    }

    .feedback-points.negative { color: #ef4444; }

    .feedback-streak {
      font-size: 0.9em;
      color: #a9b5c6;
    }

    /* Estado: Acabou */
    .ended-state {
      display: none;
      padding: 50px 30px;
      text-align: center;
    }

    .ended-icon {
      font-size: 4em;
      margin-bottom: 20px;
    }

    .ended-title {
      font-size: 1.5em;
      font-weight: 800;
      margin-bottom: 10px;
    }

    .ended-subtitle {
      color: #a9b5c6;
      margin-bottom: 20px;
    }

    /* Eliminado */
    .eliminated-banner {
      display: none;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));
      border: 2px solid rgba(239, 68, 68, 0.4);
      border-radius: 16px;
      padding: 25px;
      text-align: center;
      margin-bottom: 20px;
    }

    .eliminated-icon {
      font-size: 3em;
      margin-bottom: 10px;
    }

    .eliminated-title {
      font-size: 1.2em;
      font-weight: 700;
      color: #ef4444;
    }

    .eliminated-subtitle {
      font-size: 0.9em;
      color: #a9b5c6;
      margin-top: 5px;
    }

    /* Toast */
    .toast {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      padding: 14px 28px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 12px;
      color: #fff;
      font-weight: 600;
      z-index: 1000;
      opacity: 0;
      transition: all 0.3s ease;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Loading */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      min-height: 60vh;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #ffb547;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 20px;
      color: #a9b5c6;
    }

    /* Responsive */
    @media (max-width: 480px) {
      .arena-header-content {
        flex-wrap: wrap;
        gap: 10px;
      }

      .arena-timer {
        order: -1;
        width: 100%;
        justify-content: center;
      }

      .my-status-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .question-text {
        font-size: 1.1em;
      }
    }
  </style>
</head>

<body>

  <!-- Loading State -->
  <div id="loadingState" class="loading-container">
    <div class="spinner"></div>
    <p class="loading-text">Entrando na arena...</p>
  </div>

  <!-- Main Arena (hidden until loaded) -->
  <div id="arenaMain" style="display: none;">
    
    <!-- Header da Arena -->
    <div class="arena-header">
      <div class="arena-header-content">
        <div class="arena-tema">
          <span class="arena-tema-icon" id="arenaTemaIcon">‚öΩ</span>
          <span class="arena-tema-nome" id="arenaTema">Carregando...</span>
          <span class="arena-modo" id="arenaModo">Normal</span>
        </div>
        
        <div class="arena-timer" id="arenaTimer">
          <span class="timer-icon">‚è±Ô∏è</span>
          <span class="timer-value" id="timerValue">00:00</span>
        </div>
        
        <div class="arena-prize">
          <span>üèÜ</span>
          <span id="arenaPrize">0</span>
        </div>
      </div>
    </div>

    <!-- Container Principal -->
    <div class="arena-container">
      
      <!-- Banner Eliminado (Sobreviv√™ncia) -->
      <div class="eliminated-banner" id="eliminatedBanner">
        <div class="eliminated-icon">üíÄ</div>
        <div class="eliminated-title">Voc√™ foi eliminado!</div>
        <div class="eliminated-subtitle">Aguarde o final para ver o resultado</div>
      </div>

      <!-- Ranking ao Vivo -->
      <div class="ranking-card">
        <div class="ranking-title">
          <span>üìä</span> Ranking ao Vivo
        </div>
        <div class="ranking-list" id="rankingList">
          <!-- Preenchido via JS -->
        </div>
      </div>

      <!-- Meu Status -->
      <div class="my-status-card">
        <div class="my-status-grid">
          <div class="my-status-item">
            <div class="my-status-value" id="myPoints">0</div>
            <div class="my-status-label">Pontos</div>
          </div>
          <div class="my-status-item">
            <div class="my-status-value green" id="myCorrect">0</div>
            <div class="my-status-label">Acertos</div>
          </div>
          <div class="my-status-item">
            <div class="my-status-value red" id="myWrong">0</div>
            <div class="my-status-label">Erros</div>
          </div>
          <div class="my-status-item" id="myStreakContainer">
            <div class="my-status-value" id="myStreak">0</div>
            <div class="my-status-label">Streak üî•</div>
          </div>
          <div class="my-status-item" id="myLivesContainer" style="display: none;">
            <div class="my-lives" id="myLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div class="my-status-label">Vidas</div>
          </div>
        </div>
      </div>

      <!-- √Årea de Perguntas -->
      <div class="question-area">
        
        <!-- Estado: Aguardando pr√≥xima pergunta -->
        <div class="waiting-state" id="waitingState">
          <div class="waiting-icon">üéØ</div>
          <div class="waiting-title">Pronto para responder?</div>
          <div class="waiting-subtitle">Clique no bot√£o para ver a pr√≥xima pergunta</div>
          <button class="btn-next-question" id="btnNextQuestion" onclick="carregarPergunta()">
            ‚ñ∂Ô∏è Pr√≥xima Pergunta
          </button>
        </div>

        <!-- Estado: Pergunta ativa -->
        <div class="question-state" id="questionState">
          <div class="question-timer-bar">
            <div class="question-timer-fill" id="questionTimerFill" style="width: 100%"></div>
          </div>
          <div class="question-header">
            <span class="question-number" id="questionNumber">Pergunta #1</span>
            <span class="question-timer-text" id="questionTimerText">
              <span>‚è±Ô∏è</span>
              <span id="questionSeconds">10</span>s
            </span>
          </div>
          <div class="question-content">
            <div class="question-text" id="questionText">Carregando pergunta...</div>
            <div class="options-list" id="optionsList">
              <!-- Preenchido via JS -->
            </div>
          </div>
        </div>

        <!-- Estado: Embate acabou -->
        <div class="ended-state" id="endedState">
          <div class="ended-icon">üèÅ</div>
          <div class="ended-title">Embate Finalizado!</div>
          <div class="ended-subtitle">Aguarde o resultado...</div>
        </div>

      </div>

    </div>

  </div>

  <!-- Feedback Overlay -->
  <div class="feedback-overlay" id="feedbackOverlay">
    <div class="feedback-card">
      <div class="feedback-icon" id="feedbackIcon">‚úÖ</div>
      <div class="feedback-title" id="feedbackTitle">Correto!</div>
      <div class="feedback-points" id="feedbackPoints">+50 pts</div>
      <div class="feedback-streak" id="feedbackStreak">üî• Streak: 3</div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="js/firebase-init.js"></script>

  <script>
    // ===================================
    // üîß VARI√ÅVEIS GLOBAIS
    // ===================================
    let currentUserId = null;
    let currentUserData = null;
    let embateId = null;
    let embateData = null;
    
    // Estado do jogo
    let gameState = {
      pontos: 0,
      acertos: 0,
      erros: 0,
      streak: 0,
      maxStreak: 0,
      vidas: 3,
      eliminado: false,
      perguntasRespondidas: [],
      perguntaAtual: null,
      totalPerguntas: 0
    };
    
    // Timers
    let mainTimerInterval = null;
    let questionTimerInterval = null;
    let questionTimeLeft = 10;
    
    // Listener do ranking
    let rankingUnsubscribe = null;

    // ===================================
    // üöÄ INICIALIZA√á√ÉO
    // ===================================
    auth.onAuthStateChanged(async user => {
      if (!user) {
        window.location.href = 'index.html';
        return;
      }

      currentUserId = user.uid;
      
      try {
        const userDoc = await db.collection('usuarios').doc(user.uid).get();
        currentUserData = userDoc.data();
        
        // Pegar ID do embate da URL
        const params = new URLSearchParams(window.location.search);
        embateId = params.get('id');
        
        if (!embateId) {
          showToast('‚ùå Embate n√£o encontrado');
          setTimeout(() => window.location.href = 'embates-pvp.html', 2000);
          return;
        }
        
        // Carregar embate
        await carregarEmbate();
        
      } catch (error) {
        console.error("Erro ao inicializar:", error);
        showToast('‚ùå Erro ao carregar arena');
      }
    });

    // ===================================
    // üìä CARREGAR EMBATE
    // ===================================
    async function carregarEmbate() {
      try {
        const doc = await db.collection('embates').doc(embateId).get();
        
        if (!doc.exists) {
          showToast('‚ùå Embate n√£o encontrado');
          setTimeout(() => window.location.href = 'embates-pvp.html', 2000);
          return;
        }
        
        embateData = { id: doc.id, ...doc.data() };
        
        // Verificar se sou participante
        if (!embateData.participantes?.includes(currentUserId)) {
          showToast('‚ùå Voc√™ n√£o est√° participando deste embate');
          setTimeout(() => window.location.href = 'embates-pvp.html', 2000);
          return;
        }
        
        // Verificar status
        if (embateData.status !== 'em_andamento') {
          if (embateData.status === 'finalizado') {
            window.location.href = `resultado-embate.html?id=${embateId}`;
          } else {
            window.location.href = `detalhes-embate.html?id=${embateId}`;
          }
          return;
        }
        
        // Carregar minha participa√ß√£o
        await carregarMinhaParticipacao();
        
        // Inicializar arena
        inicializarArena();
        
      } catch (error) {
        console.error("Erro ao carregar embate:", error);
        showToast('‚ùå Erro ao carregar embate');
      }
    }

    // ===================================
    // üë§ CARREGAR MINHA PARTICIPA√á√ÉO
    // ===================================
    async function carregarMinhaParticipacao() {
      try {
        const doc = await db.collection('embates').doc(embateId)
          .collection('participacoes').doc(currentUserId).get();
        
        if (doc.exists) {
          const data = doc.data();
          gameState.pontos = data.pontos || 0;
          gameState.acertos = data.acertos || 0;
          gameState.erros = data.erros || 0;
          gameState.streak = data.streakAtual || 0;
          gameState.maxStreak = data.streakMaximo || 0;
          gameState.vidas = data.vidasRestantes ?? 3;
          gameState.eliminado = !data.ativo;
          gameState.perguntasRespondidas = data.perguntasRespondidas || [];
          gameState.totalPerguntas = data.totalRespondidas || 0;
        } else {
          // Criar participa√ß√£o
          await db.collection('embates').doc(embateId)
            .collection('participacoes').doc(currentUserId).set({
              odId: currentUserId,
              odNome: currentUserData.usuarioUnico || 'An√¥nimo',
              ativo: true,
              vidasRestantes: 3,
              pontos: 0,
              acertos: 0,
              erros: 0,
              totalRespondidas: 0,
              streakAtual: 0,
              streakMaximo: 0,
              perguntasRespondidas: [],
              ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
      } catch (error) {
        console.error("Erro ao carregar participa√ß√£o:", error);
      }
    }

    // ===================================
    // üéÆ INICIALIZAR ARENA
    // ===================================
    function inicializarArena() {
      // Esconder loading
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('arenaMain').style.display = 'block';
      
      // Header
      const icones = { time: '‚öΩ', campeonato: 'üèÜ' };
      document.getElementById('arenaTemaIcon').textContent = icones[embateData.tema?.tipo] || '‚öîÔ∏è';
      document.getElementById('arenaTema').textContent = embateData.tema?.nome || 'Embate';
      
      const modos = { normal: 'Normal', hardcore: 'Hardcore', sobrevivencia: 'Sobreviv√™ncia' };
      document.getElementById('arenaModo').textContent = modos[embateData.modo] || 'Normal';
      
      document.getElementById('arenaPrize').textContent = embateData.prizePool || 0;
      
      // Modo sobreviv√™ncia - mostrar vidas
      if (embateData.modo === 'sobrevivencia') {
        document.getElementById('myStreakContainer').style.display = 'none';
        document.getElementById('myLivesContainer').style.display = 'block';
        atualizarVidas();
      }
      
      // Verificar se eliminado
      if (gameState.eliminado) {
        document.getElementById('eliminatedBanner').style.display = 'block';
        document.getElementById('btnNextQuestion').disabled = true;
        document.getElementById('btnNextQuestion').textContent = 'üíÄ Eliminado';
      }
      
      // Atualizar meu status
      atualizarMeuStatus();
      
      // Iniciar timer principal
      iniciarTimerPrincipal();
      
      // Escutar ranking em tempo real
      escutarRanking();
    }

    // ===================================
    // ‚è±Ô∏è TIMER PRINCIPAL
    // ===================================
    function iniciarTimerPrincipal() {
      const dataFim = embateData.dataFim?.toDate();
      if (!dataFim) return;
      
      mainTimerInterval = setInterval(() => {
        const agora = new Date();
        const diff = dataFim - agora;
        
        if (diff <= 0) {
          clearInterval(mainTimerInterval);
          finalizarEmbate();
          return;
        }
        
        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        
        document.getElementById('timerValue').textContent = 
          `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        
        // Warning quando falta menos de 1 minuto
        const timerEl = document.getElementById('arenaTimer');
        if (diff < 60000) {
          timerEl.classList.add('warning');
        }
      }, 1000);
    }

    // ===================================
    // üìä ESCUTAR RANKING
    // ===================================
    function escutarRanking() {
      rankingUnsubscribe = db.collection('embates').doc(embateId)
        .collection('participacoes')
        .orderBy('pontos', 'desc')
        .onSnapshot(snapshot => {
          const participantes = [];
          snapshot.forEach(doc => {
            participantes.push({ odId: doc.id, ...doc.data() });
          });
          renderizarRanking(participantes);
        });
    }

    function renderizarRanking(participantes) {
      const container = document.getElementById('rankingList');
      
      container.innerHTML = participantes.map((p, index) => {
        const posicao = index + 1;
        const isMe = p.odId === currentUserId;
        const posClass = posicao === 1 ? 'gold' : posicao === 2 ? 'silver' : posicao === 3 ? 'bronze' : 'normal';
        
        let vidasHtml = '';
        if (embateData.modo === 'sobrevivencia') {
          const vidas = p.vidasRestantes ?? 3;
          vidasHtml = `<div class="ranking-lives">${'‚ù§Ô∏è'.repeat(vidas)}${'üñ§'.repeat(3-vidas)}</div>`;
        }
        
        return `
          <div class="ranking-item ${isMe ? 'me' : ''} ${!p.ativo ? 'eliminated' : ''}">
            <div class="ranking-position ${posClass}">${posicao}</div>
            <div class="ranking-avatar">${p.odNome?.charAt(0).toUpperCase() || '?'}</div>
            <div class="ranking-info">
              <div class="ranking-name">${p.odNome || 'An√¥nimo'} ${isMe ? '(voc√™)' : ''}</div>
              <div class="ranking-stats">${p.acertos || 0}‚úì ${p.erros || 0}‚úó</div>
            </div>
            <div class="ranking-points">${p.pontos || 0}</div>
            ${vidasHtml}
          </div>
        `;
      }).join('');
    }

    // ===================================
    // ‚ùì CARREGAR PERGUNTA
    // ===================================
    async function carregarPergunta() {
      if (gameState.eliminado) return;
      
      const btn = document.getElementById('btnNextQuestion');
      btn.disabled = true;
      btn.textContent = '‚è≥ Carregando...';
      
      try {
        // Buscar perguntas
        let perguntas = [];
        
        // Primeiro tenta buscar por tema espec√≠fico
        if (embateData.tema?.tipo === 'time' && embateData.tema?.id) {
          const snapshotTime = await db.collection('perguntas')
            .where('timeId', '==', embateData.tema.id)
            .limit(50)
            .get();
          
          snapshotTime.forEach(doc => {
            if (!gameState.perguntasRespondidas.includes(doc.id)) {
              perguntas.push({ id: doc.id, ...doc.data() });
            }
          });
        } else if (embateData.tema?.tipo === 'campeonato' && embateData.tema?.id) {
          const snapshotCamp = await db.collection('perguntas')
            .where('campeonatoId', '==', embateData.tema.id)
            .limit(50)
            .get();
          
          snapshotCamp.forEach(doc => {
            if (!gameState.perguntasRespondidas.includes(doc.id)) {
              perguntas.push({ id: doc.id, ...doc.data() });
            }
          });
        }
        
        // Se n√£o encontrou perguntas espec√≠ficas, busca perguntas gerais
        if (perguntas.length === 0) {
          console.log("Buscando perguntas gerais...");
          const snapshotGeral = await db.collection('perguntas')
            .limit(100)
            .get();
          
          snapshotGeral.forEach(doc => {
            if (!gameState.perguntasRespondidas.includes(doc.id)) {
              perguntas.push({ id: doc.id, ...doc.data() });
            }
          });
        }
        
        // Se n√£o h√° mais perguntas
        if (perguntas.length === 0) {
          showToast('üéâ Voc√™ respondeu todas as perguntas dispon√≠veis!');
          btn.textContent = '‚úÖ Todas respondidas';
          return;
        }
        
        // Selecionar pergunta aleat√≥ria
        const pergunta = perguntas[Math.floor(Math.random() * perguntas.length)];
        gameState.perguntaAtual = pergunta;
        gameState.totalPerguntas++;
        
        // Mostrar pergunta
        mostrarPergunta(pergunta);
        
      } catch (error) {
        console.error("Erro ao carregar pergunta:", error);
        showToast('‚ùå Erro ao carregar pergunta');
        btn.disabled = false;
        btn.textContent = '‚ñ∂Ô∏è Pr√≥xima Pergunta';
      }
    }

    // ===================================
    // üìù MOSTRAR PERGUNTA
    // ===================================
    function mostrarPergunta(pergunta) {
      // Esconder waiting, mostrar question
      document.getElementById('waitingState').style.display = 'none';
      document.getElementById('questionState').style.display = 'block';
      
      // N√∫mero da pergunta
      document.getElementById('questionNumber').textContent = `Pergunta #${gameState.totalPerguntas}`;
      
      // Texto da pergunta (suporta diferentes campos)
      const textoPergunta = pergunta.pergunta || pergunta.texto || pergunta.question || '';
      document.getElementById('questionText').textContent = textoPergunta;
      
      // Alternativas - suporta diferentes estruturas
      let opcoes = [];
      
      // Estrutura 1: array de alternativas
      if (Array.isArray(pergunta.alternativas)) {
        opcoes = pergunta.alternativas;
      } 
      // Estrutura 2: array de opcoes
      else if (Array.isArray(pergunta.opcoes)) {
        opcoes = pergunta.opcoes;
      }
      // Estrutura 3: array de respostas
      else if (Array.isArray(pergunta.respostas)) {
        opcoes = pergunta.respostas;
      }
      // Estrutura 4: campos individuais (opcaoA, opcaoB, opcaoC, opcaoD)
      else if (pergunta.opcaoA || pergunta.opcao_a) {
        opcoes = [
          pergunta.opcaoA || pergunta.opcao_a || '',
          pergunta.opcaoB || pergunta.opcao_b || '',
          pergunta.opcaoC || pergunta.opcao_c || '',
          pergunta.opcaoD || pergunta.opcao_d || ''
        ].filter(o => o);
      }
      // Estrutura 5: a, b, c, d
      else if (pergunta.a || pergunta.A) {
        opcoes = [
          pergunta.a || pergunta.A || '',
          pergunta.b || pergunta.B || '',
          pergunta.c || pergunta.C || '',
          pergunta.d || pergunta.D || ''
        ].filter(o => o);
      }
      
      console.log("Pergunta:", pergunta);
      console.log("Op√ß√µes encontradas:", opcoes);
      
      const letras = ['A', 'B', 'C', 'D'];
      
      document.getElementById('optionsList').innerHTML = opcoes.map((opcao, i) => {
        // Suporta op√ß√£o como string ou objeto
        const textoOpcao = typeof opcao === 'string' ? opcao : (opcao.texto || opcao.text || opcao.label || opcao);
        return `
          <button class="option-btn" onclick="responderPergunta('${letras[i]}')" data-letra="${letras[i]}">
            <span class="option-letter">${letras[i]}</span>
            <span class="option-text">${textoOpcao}</span>
          </button>
        `;
      }).join('');
      
      // Se n√£o encontrou op√ß√µes, mostrar erro
      if (opcoes.length === 0) {
        document.getElementById('optionsList').innerHTML = `
          <div style="color: #f59e0b; text-align: center; padding: 20px;">
            ‚ö†Ô∏è Erro: Alternativas n√£o encontradas<br>
            <small>Estrutura da pergunta: ${Object.keys(pergunta).join(', ')}</small>
          </div>
        `;
      }
      
      // Iniciar timer da pergunta
      iniciarTimerPergunta();
    }

    // ===================================
    // ‚è±Ô∏è TIMER DA PERGUNTA
    // ===================================
    function iniciarTimerPergunta() {
      questionTimeLeft = 10;
      atualizarTimerPergunta();
      
      questionTimerInterval = setInterval(() => {
        questionTimeLeft--;
        atualizarTimerPergunta();
        
        if (questionTimeLeft <= 0) {
          clearInterval(questionTimerInterval);
          tempoEsgotado();
        }
      }, 1000);
    }

    function atualizarTimerPergunta() {
      const fill = document.getElementById('questionTimerFill');
      const text = document.getElementById('questionTimerText');
      const seconds = document.getElementById('questionSeconds');
      
      const percent = (questionTimeLeft / 10) * 100;
      fill.style.width = `${percent}%`;
      
      // Classes de cor
      fill.classList.remove('warning', 'danger');
      text.classList.remove('warning', 'danger');
      
      if (questionTimeLeft <= 3) {
        fill.classList.add('danger');
        text.classList.add('danger');
      } else if (questionTimeLeft <= 5) {
        fill.classList.add('warning');
        text.classList.add('warning');
      }
      
      seconds.textContent = questionTimeLeft;
    }

    // ===================================
    // ‚åõ TEMPO ESGOTADO
    // ===================================
    function tempoEsgotado() {
      // Desabilitar bot√µes
      document.querySelectorAll('.option-btn').forEach(btn => {
        btn.disabled = true;
      });
      
      // Buscar resposta correta - suporta diferentes estruturas
      let correta = gameState.perguntaAtual.correta 
        || gameState.perguntaAtual.respostaCorreta 
        || gameState.perguntaAtual.resposta
        || gameState.perguntaAtual.answer
        || gameState.perguntaAtual.correct
        || 'A';
      
      // Se for n√∫mero, converter para letra
      if (typeof correta === 'number') {
        const letras = ['A', 'B', 'C', 'D'];
        correta = letras[correta] || 'A';
      }
      
      // Se for min√∫scula, converter para mai√∫scula
      if (typeof correta === 'string') {
        correta = correta.toUpperCase();
      }
      
      // Mostrar resposta correta
      document.querySelectorAll('.option-btn').forEach(btn => {
        if (btn.dataset.letra === correta) {
          btn.classList.add('correct');
        }
      });
      
      // Feedback
      mostrarFeedback('timeout', 0);
      
      // Registrar
      registrarResposta(null, false);
    }

    // ===================================
    // ‚úÖ RESPONDER PERGUNTA
    // ===================================
    async function responderPergunta(letra) {
      // Parar timer
      clearInterval(questionTimerInterval);
      
      // Desabilitar bot√µes
      document.querySelectorAll('.option-btn').forEach(btn => {
        btn.disabled = true;
      });
      
      const tempoResposta = 10 - questionTimeLeft;
      
      // Buscar resposta correta - suporta diferentes estruturas
      let correta = gameState.perguntaAtual.correta 
        || gameState.perguntaAtual.respostaCorreta 
        || gameState.perguntaAtual.resposta
        || gameState.perguntaAtual.answer
        || gameState.perguntaAtual.correct
        || 'A';
      
      // Se for n√∫mero (0, 1, 2, 3), converter para letra
      if (typeof correta === 'number') {
        const letras = ['A', 'B', 'C', 'D'];
        correta = letras[correta] || 'A';
      }
      
      // Se for min√∫scula, converter para mai√∫scula
      if (typeof correta === 'string') {
        correta = correta.toUpperCase();
      }
      
      console.log("Resposta correta:", correta, "| Selecionada:", letra);
      
      const acertou = letra === correta;
      
      // Marcar selecionado
      const btnSelecionado = document.querySelector(`[data-letra="${letra}"]`);
      if (btnSelecionado) btnSelecionado.classList.add('selected');
      
      // Mostrar correta
      const btnCorreta = document.querySelector(`[data-letra="${correta}"]`);
      if (btnCorreta) btnCorreta.classList.add('correct');
      
      // Se errou, marcar errada
      if (!acertou && btnSelecionado) {
        btnSelecionado.classList.add('wrong');
      }
      
      // Calcular pontos
      let pontos = 0;
      
      if (acertou) {
        // Base
        pontos = 50;
        
        // B√¥nus tempo
        if (tempoResposta <= 3) pontos += 30;
        else if (tempoResposta <= 5) pontos += 20;
        else if (tempoResposta <= 7) pontos += 10;
        else if (tempoResposta <= 10) pontos += 5;
        
        // B√¥nus streak
        gameState.streak++;
        if (gameState.streak >= 10) pontos += 100;
        else if (gameState.streak >= 7) pontos += 50;
        else if (gameState.streak >= 5) pontos += 25;
        else if (gameState.streak >= 3) pontos += 10;
        
        if (gameState.streak > gameState.maxStreak) {
          gameState.maxStreak = gameState.streak;
        }
        
        gameState.acertos++;
        gameState.pontos += pontos;
        
      } else {
        gameState.streak = 0;
        gameState.erros++;
        
        // Modo hardcore - perde pontos
        if (embateData.modo === 'hardcore') {
          pontos = -20;
          gameState.pontos += pontos;
        }
        
        // Modo sobreviv√™ncia - perde vida
        if (embateData.modo === 'sobrevivencia') {
          gameState.vidas--;
          atualizarVidas();
          
          if (gameState.vidas <= 0) {
            gameState.eliminado = true;
          }
        }
      }
      
      // Mostrar feedback
      mostrarFeedback(acertou ? 'correct' : 'wrong', pontos);
      
      // Registrar resposta
      await registrarResposta(letra, acertou, pontos, tempoResposta);
      
      // Atualizar UI
      atualizarMeuStatus();
    }

    // ===================================
    // üíæ REGISTRAR RESPOSTA
    // ===================================
    async function registrarResposta(letra, acertou, pontos = 0, tempoResposta = 10) {
      try {
        // Adicionar √† lista de respondidas
        gameState.perguntasRespondidas.push(gameState.perguntaAtual.id);
        
        // Salvar resposta
        await db.collection('embates').doc(embateId)
          .collection('respostas').add({
            odId: currentUserId,
            perguntaId: gameState.perguntaAtual.id,
            alternativaSelecionada: letra,
            correta: acertou,
            pontos: pontos,
            tempoResposta: tempoResposta,
            streakNoMomento: gameState.streak,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        // Atualizar participa√ß√£o
        await db.collection('embates').doc(embateId)
          .collection('participacoes').doc(currentUserId).update({
            pontos: gameState.pontos,
            acertos: gameState.acertos,
            erros: gameState.erros,
            streakAtual: gameState.streak,
            streakMaximo: gameState.maxStreak,
            vidasRestantes: gameState.vidas,
            ativo: !gameState.eliminado,
            totalRespondidas: gameState.totalPerguntas,
            perguntasRespondidas: firebase.firestore.FieldValue.arrayUnion(gameState.perguntaAtual.id),
            ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp()
          });
          
      } catch (error) {
        console.error("Erro ao registrar resposta:", error);
      }
    }

    // ===================================
    // üéâ MOSTRAR FEEDBACK
    // ===================================
    function mostrarFeedback(tipo, pontos) {
      const overlay = document.getElementById('feedbackOverlay');
      const icon = document.getElementById('feedbackIcon');
      const title = document.getElementById('feedbackTitle');
      const pts = document.getElementById('feedbackPoints');
      const streak = document.getElementById('feedbackStreak');
      
      if (tipo === 'correct') {
        icon.textContent = '‚úÖ';
        title.textContent = 'Correto!';
        title.className = 'feedback-title correct';
        pts.textContent = `+${pontos} pts`;
        pts.className = 'feedback-points';
        streak.textContent = gameState.streak > 1 ? `üî• Streak: ${gameState.streak}` : '';
      } else if (tipo === 'wrong') {
        icon.textContent = '‚ùå';
        title.textContent = 'Errado!';
        title.className = 'feedback-title wrong';
        pts.textContent = pontos < 0 ? `${pontos} pts` : '0 pts';
        pts.className = pontos < 0 ? 'feedback-points negative' : 'feedback-points';
        streak.textContent = gameState.vidas > 0 && embateData.modo === 'sobrevivencia' 
          ? `‚ù§Ô∏è Vidas restantes: ${gameState.vidas}` 
          : '';
      } else {
        icon.textContent = '‚è∞';
        title.textContent = 'Tempo esgotado!';
        title.className = 'feedback-title timeout';
        pts.textContent = '0 pts';
        pts.className = 'feedback-points';
        streak.textContent = '';
      }
      
      overlay.classList.add('show');
      
      // Esconder ap√≥s 1.5s e voltar para waiting
      setTimeout(() => {
        overlay.classList.remove('show');
        
        // Verificar se foi eliminado
        if (gameState.eliminado) {
          document.getElementById('eliminatedBanner').style.display = 'block';
          document.getElementById('questionState').style.display = 'none';
          document.getElementById('waitingState').style.display = 'block';
          document.getElementById('btnNextQuestion').disabled = true;
          document.getElementById('btnNextQuestion').textContent = 'üíÄ Eliminado';
        } else {
          // Voltar para waiting
          document.getElementById('questionState').style.display = 'none';
          document.getElementById('waitingState').style.display = 'block';
          document.getElementById('btnNextQuestion').disabled = false;
          document.getElementById('btnNextQuestion').textContent = '‚ñ∂Ô∏è Pr√≥xima Pergunta';
        }
      }, 1500);
    }

    // ===================================
    // üìä ATUALIZAR MEU STATUS
    // ===================================
    function atualizarMeuStatus() {
      document.getElementById('myPoints').textContent = gameState.pontos;
      document.getElementById('myCorrect').textContent = gameState.acertos;
      document.getElementById('myWrong').textContent = gameState.erros;
      document.getElementById('myStreak').textContent = gameState.streak;
    }

    function atualizarVidas() {
      const container = document.getElementById('myLives');
      container.innerHTML = '‚ù§Ô∏è'.repeat(gameState.vidas) + 'üñ§'.repeat(3 - gameState.vidas);
    }

    // ===================================
    // üèÅ FINALIZAR EMBATE
    // ===================================
    function finalizarEmbate() {
      // Parar timers
      clearInterval(mainTimerInterval);
      clearInterval(questionTimerInterval);
      
      // Parar listener
      if (rankingUnsubscribe) rankingUnsubscribe();
      
      // Mostrar estado finalizado
      document.getElementById('waitingState').style.display = 'none';
      document.getElementById('questionState').style.display = 'none';
      document.getElementById('endedState').style.display = 'block';
      
      // Timer value
      document.getElementById('timerValue').textContent = '00:00';
      
      showToast('üèÅ Embate finalizado!');
      
      // Redirecionar para resultado ap√≥s 3s
      setTimeout(() => {
        window.location.href = `resultado-embate.html?id=${embateId}`;
      }, 3000);
    }

    // ===================================
    // üçû TOAST
    // ===================================
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    // ===================================
    // üßπ CLEANUP
    // ===================================
    window.addEventListener('beforeunload', () => {
      if (rankingUnsubscribe) rankingUnsubscribe();
      clearInterval(mainTimerInterval);
      clearInterval(questionTimerInterval);
    });

    console.log("‚úÖ Arena Embate v1.0 carregado");
  </script>

</body>
</html>
