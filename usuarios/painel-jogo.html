<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jogo ao Vivo - Yellup</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --cor-timeA: #28a745;
      --cor-timeB: #dc3545;
      --bg-primary: #0a0e27;
      --bg-secondary: #1a1f3a;
      --bg-card: #252b48;
      --text-primary: #ffffff;
      --text-secondary: #a8b3cf;
      --accent: #ffb547;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Anima√ß√£o de fundo */
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: 
        radial-gradient(circle at 20% 50%, rgba(40, 167, 69, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(220, 53, 69, 0.1) 0%, transparent 50%);
      animation: rotateBg 20s linear infinite;
      z-index: 0;
    }

    @keyframes rotateBg {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 181, 71, 0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 20px;
      font-size: 1.2em;
      color: var(--text-secondary);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      position: relative;
      z-index: 1;
      display: none;
    }

    .container.loaded {
      display: block;
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* ‚úÖ Anima√ß√µes Toast */
    @keyframes toastSlideUp {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    
    @keyframes toastSlideDown {
      from { opacity: 1; transform: translateX(-50%) translateY(0); }
      to { opacity: 0; transform: translateX(-50%) translateY(20px); }
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .btn-back {
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: white;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
    }

    .btn-back:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateX(-5px);
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), #ff8c42);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 18px;
    }

    /* ==================== CAMISETA SVG ==================== */
    .team-jersey {
      width: 45px;
      height: 52px;
      margin: 0 auto 8px;
    }

    .team-jersey-small {
      width: 25px;
      height: 30px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
    }

    /* Match Header */
    .match-header {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideDown 0.6s ease-out;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .match-title {
      text-align: center;
      font-size: 1.8em;
      font-weight: 800;
      margin-bottom: 20px;
      background: linear-gradient(135deg, #fff, var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .match-info {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
      color: var(--text-secondary);
      font-size: 0.95em;
    }

    /* Teams Section - MODERNIZADO */
    .teams-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }

    .team-card {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 16px;
      padding: 15px;
      text-align: center;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .team-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .team-card.my-team {
      border: 2px solid var(--accent);
      box-shadow: 0 0 15px rgba(255, 181, 71, 0.3);
    }

    .team-name {
      font-size: 1em;
      font-weight: 700;
      padding: 8px 12px;
      border-radius: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .team-stats {
      display: flex;
      justify-content: space-around;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      display: block;
      font-size: 1.8em;
      font-weight: 800;
      color: var(--accent);
    }

    .stat-label {
      font-size: 0.85em;
      color: var(--text-secondary);
    }

    /* ==================== BARRAS DE FOR√áA ==================== */
    .force-bars-container {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .force-bar-section {
      margin-bottom: 20px;
    }

    .force-bar-section:last-child {
      margin-bottom: 0;
    }

    .force-bar-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 0.9em;
    }

    .force-bar-title .team-label {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .force-bar-wrapper {
      height: 30px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      overflow: hidden;
      display: flex;
      position: relative;
    }

    .force-bar {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.85em;
      transition: width 0.5s ease;
      min-width: 50px;
    }

    .force-bar.team-a {
      background: linear-gradient(90deg, var(--cor-timeA), var(--cor-timeA-dark, var(--cor-timeA)));
    }

    .force-bar.team-b {
      background: linear-gradient(90deg, var(--cor-timeB-dark, var(--cor-timeB)), var(--cor-timeB));
    }

    /* Progress Container (barras antigas - mantido para compatibilidade) */
    .progress-container {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: none; /* Substitu√≠do pelas novas barras */
    }

    /* Answer Section */
    .answer-section {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .credits-display {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }

    .credit-badge {
      padding: 12px 20px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95em;
    }

    .credit-badge.free {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .credit-badge.paid {
      background: linear-gradient(135deg, rgba(255, 181, 71, 0.2), rgba(255, 181, 71, 0.1));
      border: 1px solid rgba(255, 181, 71, 0.3);
    }

    .btn-answer {
      width: 100%;
      padding: 20px;
      font-size: 1.3em;
      font-weight: 700;
      border: none;
      border-radius: 15px;
      background: linear-gradient(135deg, var(--accent), #ff8c42);
      color: var(--bg-primary);
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 10px 30px rgba(255, 181, 71, 0.3);
    }

    .btn-answer:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 15px 40px rgba(255, 181, 71, 0.4);
    }

    .btn-answer:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* ==================== TIMER DA PERGUNTA ==================== */
    .question-timer {
      text-align: center;
      margin-bottom: 20px;
    }

    .timer-circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--bg-card), var(--bg-secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      position: relative;
      border: 4px solid var(--accent);
    }

    .timer-circle.warning {
      border-color: var(--warning);
      animation: pulse 0.5s infinite;
    }

    .timer-circle.danger {
      border-color: var(--danger);
      animation: pulse 0.3s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .timer-value {
      font-size: 2em;
      font-weight: 800;
      color: var(--accent);
    }

    .timer-circle.warning .timer-value {
      color: var(--warning);
    }

    .timer-circle.danger .timer-value {
      color: var(--danger);
    }

    .timer-label {
      margin-top: 10px;
      font-size: 0.9em;
      color: var(--text-secondary);
    }

    /* ==================== MODAL FULLSCREEN DA PERGUNTA ==================== */
    .question-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      z-index: 9998;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .question-modal-overlay.active {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    .question-modal {
      background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
      border-radius: 24px;
      padding: 30px;
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      border: 2px solid rgba(255, 181, 71, 0.3);
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      animation: modalSlideUp 0.4s ease;
    }

    @keyframes modalSlideUp {
      from { opacity: 0; transform: translateY(50px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .question-modal-close {
      position: absolute;
      top: 15px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      font-size: 24px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s;
    }

    .question-modal-close:hover {
      background: rgba(239, 68, 68, 0.5);
    }

    /* Question Container (dentro do modal) */
    .question-container {
      display: block;
    }

    .question-text {
      font-size: 1.3em;
      font-weight: 600;
      text-align: center;
      padding: 25px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 16px;
      margin-bottom: 25px;
      line-height: 1.6;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .question-points {
      text-align: center;
      margin-bottom: 20px;
      color: var(--accent);
      font-weight: 700;
      font-size: 1.1em;
    }

    .options-container {
      display: grid;
      gap: 15px;
    }

    .option-btn {
      padding: 18px 25px;
      font-size: 1em;
      font-weight: 500;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      font-family: 'Poppins', sans-serif;
    }

    .option-btn:hover:not(:disabled) {
      border-color: var(--accent);
      background: rgba(255, 181, 71, 0.1);
      transform: translateX(5px);
    }

    .option-btn:disabled {
      cursor: not-allowed;
    }

    .option-btn.correct {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(16, 185, 129, 0.1));
      border-color: var(--success);
      animation: correctPulse 0.5s ease;
    }

    .option-btn.wrong {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.1));
      border-color: var(--danger);
      animation: wrongShake 0.5s ease;
    }

    @keyframes correctPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    @keyframes wrongShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    /* üî• STREAK E GAMIFICA√á√ÉO */
    .streak-container {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .streak-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: linear-gradient(135deg, rgba(255, 100, 50, 0.2), rgba(255, 50, 50, 0.1));
      border: 2px solid rgba(255, 100, 50, 0.5);
      border-radius: 50px;
      transition: all 0.3s ease;
    }

    .streak-badge.active {
      animation: streakPulse 1s ease infinite;
      box-shadow: 0 0 20px rgba(255, 100, 50, 0.5);
    }

    @keyframes streakPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .streak-icon {
      font-size: 1.5em;
    }

    .streak-count {
      font-size: 1.8em;
      font-weight: 800;
      color: #ff6432;
    }

    .streak-label {
      color: #a8b3cf;
      font-size: 0.85em;
    }

    .multiplier-badge {
      display: flex;
      align-items: center;
      padding: 10px 20px;
      background: linear-gradient(135deg, rgba(147, 51, 234, 0.3), rgba(79, 70, 229, 0.2));
      border: 2px solid rgba(147, 51, 234, 0.6);
      border-radius: 50px;
      font-weight: 800;
      font-size: 1.2em;
      color: #a78bfa;
      animation: multiplierGlow 2s ease infinite;
    }

    @keyframes multiplierGlow {
      0%, 100% { box-shadow: 0 0 10px rgba(147, 51, 234, 0.3); }
      50% { box-shadow: 0 0 25px rgba(147, 51, 234, 0.6); }
    }

    /* üèÖ CONQUISTA POPUP */
    .achievement-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: linear-gradient(135deg, #1a1f3a, #252b48);
      border: 3px solid #ffb547;
      border-radius: 20px;
      padding: 30px 50px;
      text-align: center;
      z-index: 10000;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      animation: achievementPop 0.5s ease forwards;
    }

    @keyframes achievementPop {
      0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
      50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
      100% { transform: translate(-50%, -50%) scale(1) rotate(0); }
    }

    .achievement-popup .emoji {
      font-size: 4em;
      margin-bottom: 10px;
      animation: bounce 0.5s ease infinite alternate;
    }

    @keyframes bounce {
      from { transform: translateY(0); }
      to { transform: translateY(-10px); }
    }

    .achievement-popup .title {
      font-size: 1.5em;
      font-weight: 800;
      color: #ffb547;
      margin-bottom: 5px;
    }

    .achievement-popup .description {
      color: #a8b3cf;
      margin-bottom: 10px;
    }

    .achievement-popup .bonus {
      color: #10b981;
      font-weight: 700;
    }

    .achievement-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      opacity: 0;
      animation: fadeIn 0.3s ease forwards;
    }

    /* üí∞ PATROCINADOR POPUP */
    .sponsor-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a1f3a, #252b48);
      border: 2px solid rgba(255, 181, 71, 0.5);
      border-radius: 20px;
      padding: 25px;
      max-width: 380px;
      width: 90%;
      text-align: center;
      z-index: 10000;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      display: none;
    }

    .sponsor-popup.active {
      display: block;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translate(-50%, -60%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }

    .sponsor-header {
      font-size: 0.9em;
      color: #ffb547;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .sponsor-logo {
      width: 100px;
      height: 100px;
      margin: 0 auto 15px;
      background: linear-gradient(135deg, #fff, #f0f0f0);
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3em;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .sponsor-logo-img {
      width: 100px;
      height: 100px;
      margin: 0 auto 15px;
      border-radius: 20px;
      object-fit: cover;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }

    .sponsor-name {
      font-size: 1.4em;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #fff, #a8b3cf);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .sponsor-desc {
      font-size: 0.9em;
      color: #a8b3cf;
      margin-bottom: 15px;
    }

    .sponsor-reward {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(16, 185, 129, 0.5);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      color: #10b981;
      font-size: 1em;
    }
    
    .sponsor-reward strong {
      font-size: 1.3em;
      color: #2ecc71;
    }

    .sponsor-btn {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-weight: 700;
      font-size: 1.1em;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      transition: all 0.3s ease;
      margin-bottom: 10px;
    }

    .sponsor-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
    }

    .sponsor-skip {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      color: #a8b3cf;
      cursor: pointer;
      font-size: 0.9em;
      font-family: 'Poppins', sans-serif;
      padding: 10px 20px;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .sponsor-skip:hover {
      color: #fff;
      border-color: rgba(255,255,255,0.4);
    }
    
    .sponsor-timer {
      margin-top: 12px;
      font-size: 0.8em;
      color: #666;
    }
    
    .sponsor-timer span {
      color: #f39c12;
      font-weight: 600;
    }

    .result-message {
      display: none;
      text-align: center;
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      font-weight: 600;
      font-size: 1.1em;
    }

    .result-message.success {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: var(--success);
    }

    .result-message.error {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--danger);
    }

    .result-message.timeout {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.1));
      border: 1px solid rgba(245, 158, 11, 0.3);
      color: var(--warning);
    }

    /* Chat and Ranking Grid */
    .chat-ranking-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    @media (min-width: 992px) {
      .chat-ranking-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    .chat-section {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 20px;
      padding: 25px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chat-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .chat-tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.05);
      font-weight: 600;
    }

    .chat-tab:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .chat-tab.active {
      background: linear-gradient(135deg, var(--accent), #ff8c42);
      color: var(--bg-primary);
    }

    .chat-content {
      display: none;
    }

    .chat-content.active {
      display: block;
    }

    .chat-messages {
      height: 300px;
      overflow-y: auto;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      margin-bottom: 15px;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 3px;
    }

    .chat-message {
      display: flex;
      gap: 12px;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      animation: fadeIn 0.3s ease;
    }

    .chat-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
    }

    .chat-content-msg {
      flex: 1;
    }

    .chat-author {
      font-weight: 600;
      color: var(--accent);
      font-size: 0.9em;
      margin-bottom: 4px;
    }

    .chat-text {
      color: var(--text-primary);
      font-size: 0.95em;
      line-height: 1.4;
    }

    .chat-input-container {
      display: flex;
      gap: 10px;
    }

    .chat-input {
      flex: 1;
      padding: 12px 15px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.2);
      color: white;
      font-size: 0.95em;
      font-family: 'Poppins', sans-serif;
    }

    .chat-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .chat-send-btn {
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--accent), #ff8c42);
      border: none;
      border-radius: 10px;
      color: var(--bg-primary);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Poppins', sans-serif;
    }

    .chat-send-btn:hover {
      transform: scale(1.05);
    }

    /* Ranking Section */
    .ranking-section {
      background: linear-gradient(135deg, var(--bg-card) 0%, rgba(37, 43, 72, 0.8) 100%);
      border-radius: 20px;
      padding: 25px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .ranking-title {
      text-align: center;
      font-size: 1.3em;
      margin-bottom: 20px;
      color: var(--accent);
    }

    .ranking-list {
      list-style: none;
    }

    .ranking-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
    }

    .ranking-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateX(5px);
    }

    .ranking-item:first-child {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
      border: 1px solid rgba(255, 215, 0, 0.3);
    }

    .ranking-position {
      font-size: 1.3em;
      font-weight: 800;
      min-width: 35px;
      text-align: center;
    }

    .ranking-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
    }
    
    .ranking-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .ranking-name {
      font-weight: 500;
    }
    
    .ranking-time {
      font-size: 0.75em;
      color: var(--text-secondary);
    }
    
    .ranking-stats {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .ranking-points {
      font-weight: 700;
      color: var(--accent);
    }
    
    .ranking-credits {
      font-size: 0.85em;
      color: #2ecc71;
      font-weight: 600;
    }
    
    /* Premia√ß√£o Info */
    .premiacao-info {
      margin-bottom: 15px;
      padding: 12px;
      border-radius: 12px;
      text-align: center;
    }
    
    .premiacao-aviso {
      background: rgba(241, 196, 15, 0.15);
      border: 1px solid rgba(241, 196, 15, 0.3);
      padding: 12px;
      border-radius: 10px;
      color: #f1c40f;
    }
    
    .premiacao-aviso small {
      opacity: 0.7;
    }
    
    .premiacao-ativa {
      background: rgba(46, 204, 113, 0.15);
      border: 1px solid rgba(46, 204, 113, 0.3);
      padding: 12px;
      border-radius: 10px;
      color: #2ecc71;
      text-align: center;
      font-size: 1.1em;
    }
    
    .premiacao-breakdown {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 8px;
      font-size: 0.85em;
      flex-wrap: wrap;
    }
    
    .premiacao-breakdown span {
      background: rgba(0,0,0,0.2);
      padding: 4px 8px;
      border-radius: 6px;
    }
    
    /* Modal de Premia√ß√£o */
    .premiacao-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
      animation: fadeIn 0.3s ease;
    }
    
    .premiacao-modal {
      background: var(--bg-secondary);
      border-radius: 20px;
      padding: 25px;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      border: 2px solid var(--accent);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    
    .premiacao-modal h2 {
      text-align: center;
      margin-bottom: 20px;
      background: linear-gradient(135deg, #ffd700, #ffb347);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .premiacao-total {
      text-align: center;
      padding: 15px;
      background: rgba(255,181,71,0.1);
      border-radius: 12px;
      margin-bottom: 20px;
    }
    
    .premiacao-total small {
      opacity: 0.7;
    }
    
    .premiacao-secao {
      margin-bottom: 20px;
    }
    
    .premiacao-secao h3 {
      margin-bottom: 10px;
      font-size: 1.1em;
    }
    
    .premiacao-lista {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .premiacao-lista li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      margin-bottom: 6px;
    }
    
    .premiacao-lista li:first-child {
      background: rgba(255,215,0,0.15);
      border: 1px solid rgba(255,215,0,0.3);
    }
    
    .premiacao-sorteios {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .premiacao-sortudo {
      text-align: center;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }
    
    .premiacao-sortudo h4 {
      margin-bottom: 8px;
      font-size: 0.95em;
    }
    
    .premiacao-sortudo p {
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .premiacao-sortudo span {
      color: #2ecc71;
      font-weight: 700;
      display: block;
      margin-bottom: 5px;
    }
    
    .premiacao-sortudo small {
      opacity: 0.6;
      font-size: 0.8em;
    }
    
    .btn-fechar-premiacao {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, var(--accent), #ff8c42);
      border: none;
      border-radius: 12px;
      color: white;
      font-weight: 700;
      font-size: 1.1em;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .btn-fechar-premiacao:hover {
      transform: scale(1.02);
    }
    
    /* ========== ANIMA√á√ÉO DE PREMIA√á√ÉO PESSOAL ========== */
    .vitoria-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20000;
      animation: fadeIn 0.5s ease;
    }

    .vitoria-modal {
      text-align: center;
      padding: 40px 30px;
      max-width: 400px;
      animation: bounceIn 0.6s ease;
    }

    @keyframes bounceIn {
      0% { transform: scale(0.3); opacity: 0; }
      50% { transform: scale(1.05); }
      70% { transform: scale(0.95); }
      100% { transform: scale(1); opacity: 1; }
    }

    .vitoria-medalha {
      font-size: 80px;
      animation: spin3d 2s ease infinite;
      margin-bottom: 20px;
    }

    @keyframes spin3d {
      0% { transform: rotateY(0deg); }
      100% { transform: rotateY(360deg); }
    }

    .vitoria-posicao {
      font-size: 3em;
      font-weight: 900;
      background: linear-gradient(135deg, #ffd700, #ffb347, #ff8c42);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-shadow: 0 0 30px rgba(255,215,0,0.5);
    }

    .vitoria-texto {
      font-size: 1.3em;
      color: #fff;
      margin-bottom: 25px;
    }

    .vitoria-premio {
      display: inline-flex;
      align-items: center;
      gap: 15px;
      background: linear-gradient(135deg, rgba(46,204,113,0.3), rgba(39,174,96,0.2));
      border: 2px solid #2ecc71;
      border-radius: 20px;
      padding: 20px 30px;
      margin-bottom: 30px;
      animation: pulseGlow 2s ease infinite;
    }

    @keyframes pulseGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(46,204,113,0.3); }
      50% { box-shadow: 0 0 40px rgba(46,204,113,0.6); }
    }

    .vitoria-premio-valor {
      font-size: 2.5em;
      font-weight: 800;
      color: #2ecc71;
    }

    .vitoria-premio-tipo {
      font-size: 0.9em;
      color: rgba(255,255,255,0.7);
    }

    .vitoria-btn {
      padding: 15px 40px;
      background: linear-gradient(135deg, var(--accent), #ff8c42);
      border: none;
      border-radius: 30px;
      color: white;
      font-weight: 700;
      font-size: 1.1em;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .vitoria-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(255,181,71,0.4);
    }

    /* Confetes */
    .confete {
      position: fixed;
      width: 10px;
      height: 10px;
      z-index: 19999;
      pointer-events: none;
    }

    @keyframes confeteFall {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    
    @media (max-width: 500px) {
      .premiacao-sorteios {
        grid-template-columns: 1fr;
      }
      
      .vitoria-medalha {
        font-size: 60px;
      }
      
      .vitoria-posicao {
        font-size: 2em;
      }
      
      .vitoria-premio-valor {
        font-size: 2em;
      }
    }

    /* Responsive - MELHORADO */
    @media (max-width: 768px) {
      .teams-section {
        grid-template-columns: 1fr 1fr; /* Manter lado a lado! */
        gap: 10px;
      }

      .team-card {
        padding: 12px 8px;
      }

      .team-jersey {
        width: 35px;
        height: 40px;
        margin-bottom: 5px;
      }

      .team-name {
        font-size: 0.8em;
        padding: 6px 8px;
      }

      .team-stats {
        gap: 10px;
      }

      .stat-value {
        font-size: 1.2em;
      }

      .stat-label {
        font-size: 0.65em;
      }

      .match-title {
        font-size: 1.2em;
      }

      .match-info {
        font-size: 0.85em;
        gap: 15px;
      }

      .chat-ranking-grid {
        grid-template-columns: 1fr;
      }

      .chat-content {
        max-height: 350px;
      }
    }

    @media (max-width: 400px) {
      .team-jersey {
        width: 30px;
        height: 35px;
      }

      .team-name {
        font-size: 0.75em;
        padding: 5px 6px;
      }

      .stat-value {
        font-size: 1em;
      }
    }
  </style>
</head>
<body>

  <!-- Loading Screen -->
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-spinner"></div>
    <p class="loading-text">Carregando jogo...</p>
  </div>

  <div class="container" id="mainContainer">
    
    <!-- Header -->
    <div class="header">
      <button class="btn-back" onclick="voltarPainel()">
        ‚Üê Voltar
      </button>
      <div class="user-info">
        <div class="user-avatar" id="userAvatar">U</div>
        <div>
          <strong id="userName">Usu√°rio</strong>
          <div style="font-size: 0.85em; color: var(--text-secondary);" id="userLevel">Level 1</div>
        </div>
      </div>
    </div>

    <!-- Match Header -->
    <div class="match-header">
      <h1 class="match-title" id="matchTitle">Time A vs Time B</h1>
      <div class="match-info">
        <span>üèÜ <span id="matchLeague">Liga</span></span>
        <span>üìÖ <span id="matchDate">Data</span></span>
        <span>‚è≥ Restante: <span class="timer" id="timer">--:--</span></span>
      </div>
    </div>

    <!-- Teams -->
    <div class="teams-section">
      <div class="team-card" id="teamACard">
        <div id="jerseyA" class="team-jersey"></div>
        <div class="team-name" id="teamAName">
          Time A
        </div>
        <div class="team-stats">
          <div class="stat">
            <span class="stat-value" id="teamATorcida">0</span>
            <span class="stat-label">Torcedores</span>
          </div>
          <div class="stat">
            <span class="stat-value" id="teamAPontos">0</span>
            <span class="stat-label">Pontos</span>
          </div>
        </div>
      </div>

      <div class="team-card" id="teamBCard">
        <div id="jerseyB" class="team-jersey"></div>
        <div class="team-name" id="teamBName">
          Time B
        </div>
        <div class="team-stats">
          <div class="stat">
            <span class="stat-value" id="teamBTorcida">0</span>
            <span class="stat-label">Torcedores</span>
          </div>
          <div class="stat">
            <span class="stat-value" id="teamBPontos">0</span>
            <span class="stat-label">Pontos</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Barras de For√ßa -->
    <div class="force-bars-container">
      <!-- Barra de Torcida -->
      <div class="force-bar-section">
        <div class="force-bar-title">
          <div class="team-label">
            <span id="forceTeamAName">Time A</span>
          </div>
          <span>üë• FOR√áA DA TORCIDA</span>
          <div class="team-label">
            <span id="forceTeamBName">Time B</span>
          </div>
        </div>
        <div class="force-bar-wrapper">
          <div class="force-bar team-a" id="forceTorcidaA" style="width: 50%;">
            <span id="forceTorcidaAPerc">50%</span>
          </div>
          <div class="force-bar team-b" id="forceTorcidaB" style="width: 50%;">
            <span id="forceTorcidaBPerc">50%</span>
          </div>
        </div>
      </div>

      <!-- Barra de Pontua√ß√£o -->
      <div class="force-bar-section">
        <div class="force-bar-title">
          <div class="team-label">
            <span id="pointsTeamAValue">0 pts</span>
          </div>
          <span>üèÜ PONTUA√á√ÉO</span>
          <div class="team-label">
            <span id="pointsTeamBValue">0 pts</span>
          </div>
        </div>
        <div class="force-bar-wrapper">
          <div class="force-bar team-a" id="forcePontosA" style="width: 50%;">
            <span id="forcePontosAPerc">50%</span>
          </div>
          <div class="force-bar team-b" id="forcePontosB" style="width: 50%;">
            <span id="forcePontosBPerc">50%</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Answer Section -->
    <div class="answer-section">
      <div class="credits-display">
        <div class="credit-badge free">
          <span>üéÅ Jogadas Gr√°tis:</span>
          <strong id="freeCredits">5/5</strong>
        </div>
        <div class="credit-badge paid">
          <span>üíé Cr√©ditos:</span>
          <strong id="paidCredits">0</strong>
        </div>
      </div>

      <!-- üî• STREAK E GAMIFICA√á√ÉO -->
      <div class="streak-container" id="streakContainer">
        <div class="streak-badge" id="streakBadge">
          <span class="streak-icon">üî•</span>
          <span class="streak-count" id="streakCount">0</span>
          <span class="streak-label">em sequ√™ncia</span>
        </div>
        <div class="multiplier-badge" id="multiplierBadge" style="display: none;">
          <span>‚ö° x<span id="multiplierValue">1</span></span>
        </div>
      </div>

      <button class="btn-answer" id="btnAnswer" onclick="getQuestion()">
        üéØ Responder Pergunta
      </button>
    </div>

    <!-- üéØ MODAL FULLSCREEN DA PERGUNTA -->
    <div class="question-modal-overlay" id="questionModalOverlay">
      <div class="question-modal">
        <div class="question-container" id="questionContainer">
          <!-- Timer da Pergunta -->
          <div class="question-timer">
            <div class="timer-circle" id="questionTimerCircle">
              <span class="timer-value" id="questionTimerValue">10</span>
            </div>
            <p class="timer-label">segundos para responder</p>
          </div>

          <div class="question-points" id="questionPoints">Vale 10 pontos</div>
          <div class="question-text" id="questionText"></div>
          <div class="options-container" id="optionsContainer"></div>
          <div class="result-message" id="resultMessage"></div>
        </div>
      </div>
    </div>

    <!-- Chat and Ranking -->
    <div class="chat-ranking-grid">
      
      <div class="chat-section">
        <div class="chat-tabs">
          <div class="chat-tab active" onclick="switchChat('team')">
            üíö Chat da Torcida
          </div>
          <div class="chat-tab" onclick="switchChat('general')">
            üí¨ Chat Geral
          </div>
        </div>

        <div class="chat-content active" id="teamChatContent">
          <div class="chat-messages" id="teamChat">
            <!-- Mensagens da torcida -->
          </div>
          <div class="chat-input-container">
            <input 
              type="text" 
              class="chat-input" 
              id="teamChatInput" 
              placeholder="Mensagem para sua torcida..."
              maxlength="200"
            />
            <button class="chat-send-btn" onclick="sendMessage('team')">
              Enviar
            </button>
          </div>
        </div>

        <div class="chat-content" id="generalChatContent">
          <div class="chat-messages" id="generalChat">
            <!-- Mensagens gerais -->
          </div>
          <div class="chat-input-container">
            <input 
              type="text" 
              class="chat-input" 
              id="generalChatInput" 
              placeholder="Mensagem para todos..."
              maxlength="200"
            />
            <button class="chat-send-btn" onclick="sendMessage('general')">
              Enviar
            </button>
          </div>
        </div>
      </div>

      <!-- Ranking Section dentro do grid -->
      <div class="ranking-section">
        <h3 class="ranking-title">üèÜ Ranking da Partida</h3>
        
        <!-- Info de Premia√ß√£o -->
        <div class="premiacao-info" id="premiacaoInfo">
          <div class="premiacao-ativa">
            üèÜ Carregando premia√ß√£o...
          </div>
        </div>
        
        <ul class="ranking-list" id="rankingList">
          <!-- Ranking ser√° inserido aqui -->
        </ul>
      </div>

    </div>

  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  
  <!-- Utilit√°rio de Bandeiras -->
  <script src="js/bandeiras-utils.js"></script>
  
  <script>
    // ===================================
    // üî• CONFIGURA√á√ÉO FIREBASE
    // ===================================
    const firebaseConfig = {
      apiKey: "AIzaSyC5ZrkEy7KuCFJOtPvI7-P-JcA0MF4im5c",
      authDomain: "painel-yellup.firebaseapp.com",
      projectId: "painel-yellup",
      storageBucket: "painel-yellup.firebasestorage.app",
      messagingSenderId: "608347210297",
      appId: "1:608347210297:web:75092713724e617c7203e8",
      measurementId: "G-SYZ16X31KQ"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();

    // ===================================
    // üì¶ VARI√ÅVEIS GLOBAIS
    // ===================================
    let uid = null;
    let jogoId = null;
    let timeTorcida = null;          // ID do time que o usu√°rio est√° torcendo
    let timeCasaId = null;           // ID do time da casa
    let timeForaId = null;           // ID do time visitante
    let timeCasaData = null;         // Dados do time da casa
    let timeForaData = null;         // Dados do time visitante
    let currentQuestion = null;
    let perguntasRespondidas = [];
    let todasPerguntasRespondidas = false;
    let questionTimer = null;        // Timer da pergunta
    let questionTimeLeft = 10;       // 10 segundos por pergunta
    let questionStartTime = null;    // ‚úÖ NOVO: Momento que a pergunta apareceu
    let jogoStatus = null;           // Status calculado (agendado, ao_vivo, finalizado)
    let jogoDataInicio = null;       // ‚úÖ NOVO: Data/hora de in√≠cio do jogo
    let jogoDataFim = null;          // ‚úÖ NOVO: Data/hora de fim do jogo
    let jogoCreditosIniciais = 0;    // ‚úÖ NOVO: Cr√©ditos iniciais do admin
    let statusCheckInterval = null;  // ‚úÖ NOVO: Intervalo para checar status
    let premiacaoExecutada = false;  // ‚úÖ NOVO: Flag para evitar premiar m√∫ltiplas vezes

    // üéÆ GAMIFICA√á√ÉO
    let streak = 0;                  // Sequ√™ncia de acertos
    let maxStreak = 0;               // Maior sequ√™ncia
    let multiplicador = 1;           // Multiplicador de pontos
    let totalAcertos = 0;            // Total de acertos no jogo
    let totalErros = 0;              // Total de erros no jogo

    // üèÖ CONQUISTAS DO JOGO
    const CONQUISTAS = {
      primeiroAcerto: { id: 'primeiroAcerto', nome: 'Primeiro Gol', emoji: '‚öΩ', descricao: 'Acertou a primeira pergunta', xpBonus: 5 },
      streak3: { id: 'streak3', nome: 'Hat-trick', emoji: 'üé©', descricao: '3 acertos seguidos', xpBonus: 15 },
      streak5: { id: 'streak5', nome: 'M√£o Quente', emoji: 'üî•', descricao: '5 acertos seguidos', xpBonus: 30 },
      streak10: { id: 'streak10', nome: 'Impar√°vel', emoji: 'üöÄ', descricao: '10 acertos seguidos', xpBonus: 50 },
      rapido: { id: 'rapido', nome: 'Velocista', emoji: '‚ö°', descricao: 'Respondeu em menos de 3 segundos', xpBonus: 10 },
      perfeito: { id: 'perfeito', nome: 'Perfeito', emoji: 'üíØ', descricao: '10 acertos sem errar', xpBonus: 100 }
    };
    let conquistasDesbloqueadas = [];

    // ===================================
    // üëï FUN√á√ÉO PARA GERAR CAMISETA SVG
    // ===================================
    function gerarCamisetaSVG(corPrimaria, corSecundaria, corTerciaria) {
      return `
        <svg viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg">
          <!-- Corpo da camiseta -->
          <path d="M25,35 L25,110 L75,110 L75,35 L60,35 L60,25 C60,20 55,15 50,15 C45,15 40,20 40,25 L40,35 Z" 
                fill="${corPrimaria}" stroke="${corSecundaria}" stroke-width="2"/>
          
          <!-- Manga esquerda -->
          <path d="M25,35 L5,50 L5,70 L25,60 Z" 
                fill="${corPrimaria}" stroke="${corSecundaria}" stroke-width="2"/>
          
          <!-- Manga direita -->
          <path d="M75,35 L95,50 L95,70 L75,60 Z" 
                fill="${corPrimaria}" stroke="${corSecundaria}" stroke-width="2"/>
          
          <!-- Detalhe manga esquerda -->
          <path d="M5,50 L15,55 L15,65 L5,70 Z" fill="${corTerciaria}"/>
          
          <!-- Detalhe manga direita -->
          <path d="M95,50 L85,55 L85,65 L95,70 Z" fill="${corTerciaria}"/>
          
          <!-- Gola -->
          <ellipse cx="50" cy="22" rx="12" ry="8" fill="${corSecundaria}"/>
          <ellipse cx="50" cy="22" rx="8" ry="5" fill="${corPrimaria}"/>
        </svg>
      `;
    }

    // ===================================
    // üîê VERIFICA√á√ÉO DE AUTENTICA√á√ÉO
    // ===================================
    auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
      .then(() => console.log("‚úÖ Persist√™ncia configurada"))
      .catch((error) => console.error("‚ùå Erro persist√™ncia:", error));

    auth.onAuthStateChanged(async (user) => {
      console.log("üîç Verificando autentica√ß√£o...");
      
      if (!user) {
        console.log("‚ùå Usu√°rio n√£o autenticado");
        setTimeout(() => window.location.href = "index.html", 500);
        return;
      }
      
      console.log("‚úÖ Usu√°rio autenticado:", user.uid);
      uid = user.uid;
      
      const params = new URLSearchParams(window.location.search);
      jogoId = params.get("jogoId");
      
      if (!jogoId) {
        alert("ID do jogo n√£o encontrado!");
        window.location.href = "painel.html";
        return;
      }

      console.log("üéÆ Carregando jogo:", jogoId);

      try {
        await loadGameData();      // Primeiro carrega dados do jogo (times)
        await loadUserData();      // Depois carrega dados do usu√°rio
        await updateStats();       // Atualiza estat√≠sticas
        initChat();                // Inicia chat
        await loadRanking();       // Carrega ranking
        await carregarPatrocinadores(); // ‚úÖ NOVO: Carrega patrocinadores da partida
        startGameTimer();          // Inicia timer do jogo
        
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("mainContainer").classList.add("loaded");
        
        console.log("‚úÖ Jogo carregado com sucesso!");
        
      } catch (error) {
        console.error("‚ùå Erro ao carregar jogo:", error);
        alert("Erro ao carregar o jogo. Tente novamente.");
        window.location.href = "painel.html";
      }
    });

    // ===================================
    // üéÆ CARREGAR DADOS DO JOGO
    // ===================================
    async function loadGameData() {
      try {
        const jogoDoc = await db.collection("jogos").doc(jogoId).get();
        if (!jogoDoc.exists) {
          throw new Error("Jogo n√£o encontrado!");
        }

        const jogo = jogoDoc.data();
        timeCasaId = jogo.timeCasaId;
        timeForaId = jogo.timeForaId;
        
        // ‚úÖ NOVO: Salvar status do jogo
        jogoStatus = jogo.status || 'agendado';
        console.log("üìä Status do jogo:", jogoStatus);
        
        // Carregar dados dos times
        const [timeCasaDoc, timeForaDoc] = await Promise.all([
          db.collection("times").doc(timeCasaId).get(),
          db.collection("times").doc(timeForaId).get()
        ]);

        timeCasaData = timeCasaDoc.exists ? { ...timeCasaDoc.data(), id: timeCasaDoc.id } : { nome: "Time Casa", primaria: "#28a745", secundaria: "#ffffff", terciaria: "#28a745", codigoPais: "BR" };
        timeForaData = timeForaDoc.exists ? { ...timeForaDoc.data(), id: timeForaDoc.id } : { nome: "Time Fora", primaria: "#dc3545", secundaria: "#ffffff", terciaria: "#dc3545", codigoPais: "BR" };

        // Obter bandeiras
        const bandeiraA = getBandeira(timeCasaData.codigoPais);
        const bandeiraB = getBandeira(timeForaData.codigoPais);

        // Atualizar cores CSS
        document.documentElement.style.setProperty('--cor-timeA', timeCasaData.primaria || '#28a745');
        document.documentElement.style.setProperty('--cor-timeB', timeForaData.primaria || '#dc3545');

        // Atualizar t√≠tulo com bandeiras
        document.getElementById("matchTitle").textContent = `${bandeiraA} ${timeCasaData.nome} vs ${timeForaData.nome} ${bandeiraB}`;
        
        // Atualizar nomes dos times com bandeiras
        document.getElementById("teamAName").textContent = `${bandeiraA} ${timeCasaData.nome}`;
        document.getElementById("teamBName").textContent = `${timeForaData.nome} ${bandeiraB}`;
        document.getElementById("forceTeamAName").textContent = `${bandeiraA} ${timeCasaData.nome}`;
        document.getElementById("forceTeamBName").textContent = `${timeForaData.nome} ${bandeiraB}`;

        // Gerar camisetas
        document.getElementById("jerseyA").innerHTML = gerarCamisetaSVG(
          timeCasaData.primaria || '#28a745',
          timeCasaData.secundaria || '#ffffff',
          timeCasaData.terciaria || '#28a745'
        );
        document.getElementById("jerseyB").innerHTML = gerarCamisetaSVG(
          timeForaData.primaria || '#dc3545',
          timeForaData.secundaria || '#ffffff',
          timeForaData.terciaria || '#dc3545'
        );

        // Aplicar estilos aos nomes
        document.getElementById("teamAName").style.background = `linear-gradient(135deg, ${timeCasaData.primaria}99, ${timeCasaData.primaria}44)`;
        document.getElementById("teamBName").style.background = `linear-gradient(135deg, ${timeForaData.primaria}99, ${timeForaData.primaria}44)`;

        // ‚úÖ NOVO: Salvar datas de in√≠cio e fim para controle de status
        if (jogo.dataInicio) {
          jogoDataInicio = jogo.dataInicio.toDate ? jogo.dataInicio.toDate() : new Date(jogo.dataInicio);
          document.getElementById("matchDate").textContent = jogoDataInicio.toLocaleDateString('pt-BR', {
            day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'
          });
        }
        
        if (jogo.dataFim) {
          jogoDataFim = jogo.dataFim.toDate ? jogo.dataFim.toDate() : new Date(jogo.dataFim);
        }
        
        console.log("üìÖ Hor√°rio in√≠cio:", jogoDataInicio);
        console.log("üìÖ Hor√°rio fim:", jogoDataFim);

        // ‚úÖ NOVO: Salvar cr√©ditos iniciais do admin
        jogoCreditosIniciais = jogo.creditosIniciais || 0;
        console.log("üí∞ Cr√©ditos iniciais do admin:", jogoCreditosIniciais);

        document.getElementById("matchLeague").textContent = jogo.liga || jogo.campeonato || "Partida";
        
        // ‚úÖ NOVO: Verificar se j√° foi premiado
        if (jogo.premiado && jogo.premiacaoDetalhes) {
          console.log("üèÜ Jogo j√° foi premiado!");
          premiacaoExecutada = true;
          // Mostrar resultado ap√≥s carregar tudo
          setTimeout(() => {
            mostrarResultadoPremiacao(jogo.premiacaoDetalhes);
          }, 2000);
        }
        
        // ‚úÖ NOVO: Calcular status baseado no hor√°rio e iniciar verifica√ß√£o cont√≠nua
        calcularStatusDoJogo();
        iniciarVerificacaoDeStatus();

      } catch (error) {
        console.error("‚ùå Erro ao carregar jogo:", error);
        throw error;
      }
    }
    
    // ‚úÖ NOVA FUN√á√ÉO: Calcular status baseado em dataInicio e dataFim
    function calcularStatusDoJogo() {
      const agora = new Date();
      const statusAnterior = jogoStatus;
      
      if (!jogoDataInicio || !jogoDataFim) {
        // Se n√£o tiver datas, considera ao vivo (fallback)
        jogoStatus = 'ao_vivo';
        console.log("‚ö†Ô∏è Datas n√£o definidas, considerando ao vivo");
      } else if (agora < jogoDataInicio) {
        jogoStatus = 'agendado';
        console.log("‚è≥ Jogo agendado - ainda n√£o come√ßou");
      } else if (agora >= jogoDataInicio && agora <= jogoDataFim) {
        jogoStatus = 'ao_vivo';
        console.log("üî¥ Jogo AO VIVO!");
      } else {
        jogoStatus = 'finalizado';
        console.log("üèÅ Jogo finalizado");
        
        // ‚úÖ NOVO: Se acabou de finalizar, executar premia√ß√£o
        if (statusAnterior !== 'finalizado' && !premiacaoExecutada) {
          setTimeout(() => {
            executarPremiacao();
          }, 2000);
        }
      }
      
      atualizarBotaoBaseadoNoStatus();
    }
    
    // ‚úÖ NOVA FUN√á√ÉO: Verificar status a cada 10 segundos
    function iniciarVerificacaoDeStatus() {
      // Limpar intervalo anterior se existir
      if (statusCheckInterval) {
        clearInterval(statusCheckInterval);
      }
      
      // Verificar a cada 10 segundos
      statusCheckInterval = setInterval(() => {
        const statusAnterior = jogoStatus;
        calcularStatusDoJogo();
        
        // Se mudou de status, mostrar mensagem
        if (statusAnterior !== jogoStatus) {
          if (jogoStatus === 'ao_vivo') {
            showToast("üî¥ O jogo come√ßou! Responda as perguntas!");
          } else if (jogoStatus === 'finalizado') {
            showToast("üèÅ O jogo terminou! Calculando premia√ß√£o...");
            // ‚úÖ NOVO: Executar premia√ß√£o autom√°tica
            setTimeout(() => {
              executarPremiacao();
            }, 3000); // Esperar 3 segundos antes de premiar
          }
        }
      }, 10000); // 10 segundos
    }
    
    // ‚úÖ FUN√á√ÉO ATUALIZADA: Atualizar bot√£o baseado no status calculado
    function atualizarBotaoBaseadoNoStatus() {
      const btnAnswer = document.getElementById("btnAnswer");
      if (!btnAnswer) return;
      
      if (jogoStatus === 'agendado') {
        btnAnswer.disabled = true;
        // Mostrar quanto tempo falta
        const agora = new Date();
        const diffMs = jogoDataInicio - agora;
        const diffMin = Math.ceil(diffMs / 60000);
        
        if (diffMin > 60) {
          const diffHoras = Math.floor(diffMin / 60);
          btnAnswer.textContent = `‚è≥ Come√ßa em ${diffHoras}h ${diffMin % 60}min`;
        } else if (diffMin > 0) {
          btnAnswer.textContent = `‚è≥ Come√ßa em ${diffMin} minutos`;
        } else {
          btnAnswer.textContent = "‚è≥ Come√ßando em breve...";
        }
        btnAnswer.style.background = "rgba(241, 196, 15, 0.5)";
        
      } else if (jogoStatus === 'finalizado') {
        btnAnswer.disabled = true;
        btnAnswer.textContent = "üèÅ Jogo finalizado";
        btnAnswer.style.background = "rgba(149, 165, 166, 0.5)";
        
      } else {
        // ao_vivo - permitir responder
        btnAnswer.disabled = false;
        btnAnswer.textContent = "üéØ Responder Pergunta";
        btnAnswer.style.background = "linear-gradient(135deg, var(--accent), #ff8c42)";
      }
    }

    // ===================================
    // üë§ CARREGAR DADOS DO USU√ÅRIO
    // ===================================
    async function loadUserData() {
      try {
        const userDoc = await db.collection("usuarios").doc(uid).get();
        if (!userDoc.exists) {
          throw new Error("Usu√°rio n√£o encontrado!");
        }

        const user = userDoc.data();
        
        const displayName = user.usuarioUnico || user.usuario || user.nome || "Usu√°rio";
        document.getElementById("userName").textContent = displayName;
        
        // Avatar - mostrar foto se existir
        const avatarEl = document.getElementById("userAvatar");
        if (user.avatarUrl) {
          avatarEl.innerHTML = `<img src="${user.avatarUrl}" alt="Avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
        } else {
          avatarEl.textContent = displayName.charAt(0).toUpperCase();
        }
        
        document.getElementById("userLevel").textContent = `Level ${user.level || 1}`;

        // Verificar se tem time escolhido para este jogo
        timeTorcida = user.torcidas?.[jogoId];
        if (!timeTorcida) {
          alert("Voc√™ precisa escolher um time primeiro!");
          window.location.href = "painel.html";
          return;
        }

        // Destacar card do time que est√° torcendo
        if (timeTorcida === timeCasaId) {
          document.getElementById("teamACard").classList.add("my-team");
        } else if (timeTorcida === timeForaId) {
          document.getElementById("teamBCard").classList.add("my-team");
        }

        // ‚úÖ GLOBAL: Carregar perguntas j√° respondidas DESTE TIME (n√£o do jogo)
        // Assim a pessoa nunca mais v√™ a mesma pergunta, mesmo em jogos diferentes
        perguntasRespondidas = user[`perguntasRespondidas_${timeTorcida}`] || [];
        console.log("üìù Perguntas j√° respondidas deste time (GLOBAL):", perguntasRespondidas.length);

        await updateFreePlays();

      } catch (error) {
        console.error("‚ùå Erro ao carregar usu√°rio:", error);
        throw error;
      }
    }

    // ===================================
    // üíé ATUALIZAR JOGADAS GR√ÅTIS (POR JOGO!)
    // ===================================
    async function updateFreePlays() {
      try {
        const userDoc = await db.collection("usuarios").doc(uid).get();
        const user = userDoc.data() || {};
        
        // ‚úÖ CORRE√á√ÉO: Jogadas gr√°tis POR JOGO, n√£o global
        const jogadasPorJogo = user.jogadasGratisPorJogo || {};
        const jogadasUsadasNesteJogo = jogadasPorJogo[jogoId] || 0;
        const creditosPagos = user.creditos || 0;
        
        const gratisRestantes = Math.max(0, 5 - jogadasUsadasNesteJogo);
        
        document.getElementById("freeCredits").textContent = `${gratisRestantes}/5`;
        document.getElementById("paidCredits").textContent = creditosPagos;

        const btnAnswer = document.getElementById("btnAnswer");
        if (gratisRestantes === 0 && creditosPagos <= 0) {
          btnAnswer.disabled = true;
          btnAnswer.textContent = "‚ùå Sem Cr√©ditos";
          btnAnswer.style.background = "rgba(239, 68, 68, 0.5)";
        } else if (!currentQuestion) {
          btnAnswer.disabled = false;
          btnAnswer.textContent = "üéØ Responder Pergunta";
          btnAnswer.style.background = "linear-gradient(135deg, var(--accent), #ff8c42)";
        }

      } catch (error) {
        console.error("‚ùå Erro ao atualizar jogadas:", error);
      }
    }

    // ===================================
    // üìä ATUALIZAR ESTAT√çSTICAS
    // ===================================
    async function updateStats() {
      try {
        const usuarios = await db.collection("usuarios").get();
        
        let torcidaA = 0, torcidaB = 0;
        let pontosA = 0, pontosB = 0;

        usuarios.forEach(doc => {
          const user = doc.data();
          const timeUser = user.torcidas?.[jogoId];
          const pontos = user.pontuacoes?.[jogoId] || 0;

          // Comparar com IDs reais dos times
          if (timeUser === timeCasaId) {
            torcidaA++;
            pontosA += pontos;
          } else if (timeUser === timeForaId) {
            torcidaB++;
            pontosB += pontos;
          }
        });

        // Atualizar cards dos times
        document.getElementById("teamATorcida").textContent = torcidaA;
        document.getElementById("teamBTorcida").textContent = torcidaB;
        document.getElementById("teamAPontos").textContent = pontosA.toLocaleString('pt-BR');
        document.getElementById("teamBPontos").textContent = pontosB.toLocaleString('pt-BR');

        // Calcular percentuais
        const totalTorcida = torcidaA + torcidaB || 1;
        const percTorcidaA = Math.round((torcidaA / totalTorcida) * 100);
        const percTorcidaB = 100 - percTorcidaA;

        const totalPontos = pontosA + pontosB || 1;
        const percPontosA = Math.round((pontosA / totalPontos) * 100);
        const percPontosB = 100 - percPontosA;

        // Atualizar barras de torcida
        document.getElementById("forceTorcidaA").style.width = percTorcidaA + "%";
        document.getElementById("forceTorcidaB").style.width = percTorcidaB + "%";
        document.getElementById("forceTorcidaAPerc").textContent = percTorcidaA + "%";
        document.getElementById("forceTorcidaBPerc").textContent = percTorcidaB + "%";

        // Atualizar barras de pontua√ß√£o
        document.getElementById("forcePontosA").style.width = percPontosA + "%";
        document.getElementById("forcePontosB").style.width = percPontosB + "%";
        document.getElementById("forcePontosAPerc").textContent = percPontosA + "%";
        document.getElementById("forcePontosBPerc").textContent = percPontosB + "%";
        document.getElementById("pointsTeamAValue").textContent = pontosA + " pts";
        document.getElementById("pointsTeamBValue").textContent = pontosB + " pts";

      } catch (error) {
        console.error("‚ùå Erro ao atualizar estat√≠sticas:", error);
      }
    }

    // ===================================
    // ‚è±Ô∏è TIMER DO JOGO
    // ===================================
    let gameTimerInterval;
    function startGameTimer() {
      // ‚úÖ CORRIGIDO: Mostrar tempo RESTANTE at√© o fim da partida
      
      function atualizarTimer() {
        const agora = new Date();
        const timerEl = document.getElementById("timer");
        const timerContainer = timerEl?.parentElement;
        
        if (!timerEl) return;
        
        // Se n√£o tem data de fim, n√£o mostrar nada
        if (!jogoDataFim) {
          timerEl.textContent = "--:--";
          return;
        }
        
        // Se o jogo ainda n√£o come√ßou - mostrar quanto falta para come√ßar
        if (jogoDataInicio && agora < jogoDataInicio) {
          const diff = jogoDataInicio - agora;
          const horas = Math.floor(diff / 3600000);
          const mins = Math.floor((diff % 3600000) / 60000);
          const secs = Math.floor((diff % 60000) / 1000);
          
          if (timerContainer) {
            timerContainer.innerHTML = `‚è≥ Come√ßa em: <span class="timer" id="timer" style="color: #f39c12;"></span>`;
            document.getElementById("timer").textContent = horas > 0 
              ? `${horas}h ${String(mins).padStart(2, '0')}m`
              : `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
          }
          return;
        }
        
        // Se o jogo j√° terminou
        if (agora > jogoDataFim) {
          if (timerContainer) {
            timerContainer.innerHTML = `<span class="timer" id="timer" style="color: #95a5a6;">üèÅ Encerrado</span>`;
          }
          clearInterval(gameTimerInterval);
          return;
        }
        
        // Jogo em andamento - mostrar tempo restante
        const diff = jogoDataFim - agora;
        const horas = Math.floor(diff / 3600000);
        const mins = Math.floor((diff % 3600000) / 60000);
        const secs = Math.floor((diff % 60000) / 1000);
        
        if (timerContainer) {
          timerContainer.innerHTML = `‚è≥ Restante: <span class="timer" id="timer"></span>`;
          const newTimerEl = document.getElementById("timer");
          
          if (horas > 0) {
            newTimerEl.textContent = `${horas}h ${String(mins).padStart(2, '0')}m`;
          } else {
            newTimerEl.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
          }
          
          // Mudar cor conforme tempo restante
          if (mins < 5 && horas === 0) {
            newTimerEl.style.color = "#e74c3c"; // Vermelho - acabando
          } else if (mins < 15 && horas === 0) {
            newTimerEl.style.color = "#f39c12"; // Amarelo - aten√ß√£o
          } else {
            newTimerEl.style.color = "#2ecc71"; // Verde - tranquilo
          }
        }
      }
      
      // Atualizar imediatamente
      atualizarTimer();
      
      // Atualizar a cada segundo
      gameTimerInterval = setInterval(atualizarTimer, 1000);
    }

    // ===================================
    // ‚ùì BUSCAR PERGUNTA (CORRIGIDO!)
    // ===================================
    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

    async function getQuestion() {
      try {
        const btnAnswer = document.getElementById("btnAnswer");
        
        // ‚úÖ Recalcular status antes de verificar (caso tenha mudado)
        calcularStatusDoJogo();
        
        // ‚úÖ Verificar se o jogo est√° ao vivo
        if (jogoStatus !== 'ao_vivo') {
          if (jogoStatus === 'agendado') {
            const agora = new Date();
            const diffMin = Math.ceil((jogoDataInicio - agora) / 60000);
            alert(`‚è≥ O jogo ainda n√£o come√ßou!\n\nCome√ßa em ${diffMin} minutos.\nAguarde o hor√°rio de in√≠cio.`);
          } else if (jogoStatus === 'finalizado') {
            alert("üèÅ Este jogo j√° foi finalizado!\n\nVeja o ranking final e aguarde a pr√≥xima partida.");
          }
          atualizarBotaoBaseadoNoStatus();
          return;
        }
        
        btnAnswer.disabled = true;
        btnAnswer.textContent = "üîç Buscando pergunta...";

        // ‚úÖ CORRE√á√ÉO: Verificar cr√©ditos POR JOGO
        const userDoc = await db.collection("usuarios").doc(uid).get();
        const userData = userDoc.data() || {};
        const jogadasPorJogo = userData.jogadasGratisPorJogo || {};
        const jogadasUsadasNesteJogo = jogadasPorJogo[jogoId] || 0;
        const creditosPagos = userData.creditos || 0;

        if (jogadasUsadasNesteJogo >= 5 && creditosPagos <= 0) {
          alert("‚ùå Voc√™ n√£o tem cr√©ditos dispon√≠veis!\n\nCompre mais cr√©ditos ou indique amigos.");
          btnAnswer.disabled = false;
          btnAnswer.textContent = "‚ùå Sem Cr√©ditos";
          return;
        }

        // ‚úÖ CORRE√á√ÉO: Buscar perguntas pelo TIME que est√° torcendo (n√£o pelo jogo)
        console.log("üîç Buscando perguntas para o time:", timeTorcida);
        
        const perguntasSnap = await db.collection("perguntas")
          .where("timeId", "==", timeTorcida)
          .get();

        console.log("üìö Perguntas encontradas:", perguntasSnap.size);

        if (perguntasSnap.empty) {
          alert("Nenhuma pergunta dispon√≠vel para este time!\n\nO administrador precisa cadastrar perguntas.");
          btnAnswer.disabled = false;
          btnAnswer.textContent = "üéØ Responder Pergunta";
          return;
        }

        // Filtrar perguntas n√£o respondidas
        const perguntasDisponiveis = [];
        perguntasSnap.forEach(doc => {
          if (!perguntasRespondidas.includes(doc.id)) {
            perguntasDisponiveis.push({ id: doc.id, ...doc.data() });
          }
        });

        console.log("üìù Perguntas dispon√≠veis (n√£o respondidas):", perguntasDisponiveis.length);

        if (perguntasDisponiveis.length === 0) {
          todasPerguntasRespondidas = true;
          alert("üéâ Parab√©ns! Voc√™ respondeu todas as perguntas deste time!");
          btnAnswer.disabled = true;
          btnAnswer.textContent = "‚úÖ Todas Respondidas";
          return;
        }

        // Escolher pergunta aleat√≥ria
        const perguntaAleatoria = perguntasDisponiveis[Math.floor(Math.random() * perguntasDisponiveis.length)];
        currentQuestion = perguntaAleatoria;

        console.log("üìù Pergunta selecionada:", currentQuestion.pergunta);

        displayQuestion();

      } catch (error) {
        console.error("‚ùå Erro ao buscar pergunta:", error);
        alert("Erro ao buscar pergunta. Tente novamente!");
        document.getElementById("btnAnswer").disabled = false;
        document.getElementById("btnAnswer").textContent = "üéØ Responder Pergunta";
      }
    }

    // ===================================
    // üìù EXIBIR PERGUNTA COM TIMER (MODAL FULLSCREEN)
    // ===================================
    function displayQuestion() {
      const modalOverlay = document.getElementById("questionModalOverlay");
      const questionContainer = document.getElementById("questionContainer");
      const questionText = document.getElementById("questionText");
      const optionsContainer = document.getElementById("optionsContainer");
      const resultMessage = document.getElementById("resultMessage");
      const questionPoints = document.getElementById("questionPoints");

      // ‚úÖ ABRIR MODAL FULLSCREEN
      modalOverlay.classList.add("active");
      
      // Resetar
      questionText.textContent = currentQuestion.pergunta;
      optionsContainer.innerHTML = "";
      resultMessage.style.display = "none";

      // Mostrar pontua√ß√£o
      const pontos = currentQuestion.pontuacao || currentQuestion.pontos || 10;
      questionPoints.textContent = `Vale ${pontos} pontos`;

      // Verificar estrutura das alternativas
      const alternativas = currentQuestion.alternativas || {};
      
      // Verificar se usa letras mai√∫sculas ou min√∫sculas
      let letras = ['a', 'b', 'c', 'd'];
      if (alternativas['A'] && !alternativas['a']) {
        letras = ['A', 'B', 'C', 'D'];
      }

      if (!letras.some(letra => alternativas[letra])) {
        alert("Erro: Pergunta sem alternativas v√°lidas!");
        document.getElementById("btnAnswer").disabled = false;
        document.getElementById("btnAnswer").textContent = "üéØ Responder Pergunta";
        questionContainer.style.display = "none";
        return;
      }

      // Criar array com as op√ß√µes e embaralhar
      const opcoes = letras
        .filter(letra => alternativas[letra])
        .map(letra => ({
          letra: letra,
          texto: alternativas[letra]
        }));

      const opcoesEmbaralhadas = shuffleArray(opcoes);

      // Criar bot√µes das op√ß√µes
      opcoesEmbaralhadas.forEach((opcao) => {
        const btn = document.createElement("button");
        btn.className = "option-btn";
        btn.textContent = opcao.texto;
        btn.onclick = () => answerQuestion(opcao.letra);
        optionsContainer.appendChild(btn);
      });

      // ‚úÖ INICIAR TIMER DE 10 SEGUNDOS
      startQuestionTimer();
    }

    // ===================================
    // ‚è±Ô∏è TIMER DA PERGUNTA (10 SEGUNDOS)
    // ===================================
    function startQuestionTimer() {
      questionTimeLeft = 10;
      questionStartTime = Date.now();  // ‚úÖ NOVO: Registrar in√≠cio
      updateTimerDisplay();

      questionTimer = setInterval(() => {
        questionTimeLeft--;
        updateTimerDisplay();

        if (questionTimeLeft <= 0) {
          clearInterval(questionTimer);
          timeoutQuestion();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const timerValue = document.getElementById("questionTimerValue");
      const timerCircle = document.getElementById("questionTimerCircle");
      
      timerValue.textContent = questionTimeLeft;

      // Mudar cor baseado no tempo
      timerCircle.classList.remove("warning", "danger");
      if (questionTimeLeft <= 3) {
        timerCircle.classList.add("danger");
      } else if (questionTimeLeft <= 5) {
        timerCircle.classList.add("warning");
      }
    }

    function stopQuestionTimer() {
      if (questionTimer) {
        clearInterval(questionTimer);
        questionTimer = null;
      }
    }

    // ===================================
    // ‚è∞ TEMPO ESGOTADO
    // ===================================
    async function timeoutQuestion() {
      try {
        // Desabilitar todas as op√ß√µes
        const options = document.querySelectorAll(".option-btn");
        options.forEach(opt => opt.disabled = true);

        // Mostrar resposta correta
        const correct = currentQuestion.correta;
        const alternativas = currentQuestion.alternativas || {};
        
        options.forEach((opt) => {
          const textoOpcao = opt.textContent;
          for (let letra in alternativas) {
            if (alternativas[letra] === textoOpcao && letra.toLowerCase() === correct.toLowerCase()) {
              opt.classList.add("correct");
              break;
            }
          }
        });

        // Mostrar mensagem de timeout
        const resultMessage = document.getElementById("resultMessage");
        resultMessage.style.display = "block";
        resultMessage.className = "result-message timeout";
        resultMessage.textContent = `‚è∞ Tempo esgotado! A resposta correta era: ${alternativas[correct]}`;

        // üî• GAMIFICA√á√ÉO - Resetar streak no timeout
        atualizarStreak(false);

        // Adicionar pergunta ao hist√≥rico
        perguntasRespondidas.push(currentQuestion.id);

        // ‚úÖ CORRE√á√ÉO: Descontar jogada gr√°tis POR JOGO
        const userDoc = await db.collection("usuarios").doc(uid).get();
        const userData = userDoc.data() || {};
        const jogadasPorJogo = userData.jogadasGratisPorJogo || {};
        const jogadasUsadasNesteJogo = jogadasPorJogo[jogoId] || 0;
        const temGratis = jogadasUsadasNesteJogo < 5;

        const updates = {
          // ‚úÖ GLOBAL: Salvar perguntas por TIME (n√£o por jogo)
          [`perguntasRespondidas_${timeTorcida}`]: firebase.firestore.FieldValue.arrayUnion(currentQuestion.id)
        };

        if (temGratis) {
          updates[`jogadasGratisPorJogo.${jogoId}`] = firebase.firestore.FieldValue.increment(1);
          console.log(`‚úÖ Usando jogada gr√°tis (${jogadasUsadasNesteJogo + 1}/5) neste jogo`);
        } else {
          updates.creditos = firebase.firestore.FieldValue.increment(-1);
          console.log(`üíé Descontando 1 cr√©dito pago`);
        }

        await db.collection("usuarios").doc(uid).update(updates);

        await updateFreePlays();

        // ‚úÖ FECHAR MODAL ap√≥s 3 segundos
        setTimeout(() => {
          currentQuestion = null;
          document.getElementById("btnAnswer").disabled = false;
          document.getElementById("btnAnswer").textContent = "üéØ Responder Pergunta";
          document.getElementById("questionModalOverlay").classList.remove("active");
        }, 3000);

      } catch (error) {
        console.error("‚ùå Erro no timeout:", error);
      }
    }

    // ===================================
    // ‚úÖ RESPONDER PERGUNTA
    // ===================================
    async function answerQuestion(selectedLetter) {
      try {
        // Parar timer e calcular tempo de resposta
        stopQuestionTimer();
        const tempoResposta = questionStartTime ? (Date.now() - questionStartTime) / 1000 : 10;
        console.log(`‚è±Ô∏è Tempo de resposta: ${tempoResposta.toFixed(2)}s`);

        // Desabilitar todas as op√ß√µes
        const options = document.querySelectorAll(".option-btn");
        options.forEach(opt => opt.disabled = true);

        const correct = currentQuestion.correta;
        const pontos = currentQuestion.pontuacao || currentQuestion.pontos || 10;
        
        // Comparar ignorando mai√∫sculas/min√∫sculas
        const acertou = selectedLetter.toLowerCase() === correct.toLowerCase();

        console.log("üìù Resposta:", selectedLetter, "| Correta:", correct, "| Acertou:", acertou);

        // Marcar resposta visualmente
        const alternativas = currentQuestion.alternativas || {};
        options.forEach((opt) => {
          const textoOpcao = opt.textContent;
          
          let letraOpcao = null;
          for (let letra in alternativas) {
            if (alternativas[letra] === textoOpcao) {
              letraOpcao = letra;
              break;
            }
          }
          
          if (letraOpcao && letraOpcao.toLowerCase() === selectedLetter.toLowerCase()) {
            opt.classList.add(acertou ? "correct" : "wrong");
          }
          if (letraOpcao && letraOpcao.toLowerCase() === correct.toLowerCase() && !acertou) {
            opt.classList.add("correct");
          }
        });

        // Mostrar resultado
        const resultMessage = document.getElementById("resultMessage");
        resultMessage.style.display = "block";
        resultMessage.className = `result-message ${acertou ? "success" : "error"}`;
        
        // üî• GAMIFICA√á√ÉO - Atualizar streak ANTES de calcular pontos
        atualizarStreak(acertou);
        
        // Calcular pontos com multiplicador
        const pontosBase = currentQuestion.pontuacao || currentQuestion.pontos || 10;
        const pontosFinais = acertou ? Math.round(pontosBase * multiplicador) : 0;
        
        if (acertou && multiplicador > 1) {
          resultMessage.innerHTML = `üéâ Correto! +${pontosFinais} pontos <span style="color: #a78bfa;">(x${multiplicador} b√¥nus!)</span>`;
        } else if (acertou) {
          resultMessage.textContent = `üéâ Correto! +${pontosFinais} pontos`;
        } else {
          resultMessage.textContent = `‚ùå Errado! A resposta correta era: ${alternativas[correct]}`;
        }

        // Adicionar pergunta ao hist√≥rico
        perguntasRespondidas.push(currentQuestion.id);

        // ‚úÖ CORRE√á√ÉO: Verificar e descontar cr√©ditos POR JOGO
        const userDoc = await db.collection("usuarios").doc(uid).get();
        const userData = userDoc.data() || {};
        const jogadasPorJogo = userData.jogadasGratisPorJogo || {};
        const jogadasUsadasNesteJogo = jogadasPorJogo[jogoId] || 0;
        const temGratis = jogadasUsadasNesteJogo < 5;

        const updates = {
          // ‚úÖ GLOBAL: Salvar perguntas por TIME (n√£o por jogo)
          [`perguntasRespondidas_${timeTorcida}`]: firebase.firestore.FieldValue.arrayUnion(currentQuestion.id)
        };

        if (temGratis) {
          updates[`jogadasGratisPorJogo.${jogoId}`] = firebase.firestore.FieldValue.increment(1);
          console.log(`‚úÖ Usando jogada gr√°tis (${jogadasUsadasNesteJogo + 1}/5) neste jogo`);
        } else {
          // ‚úÖ SISTEMA DE CR√âDITOS SEPARADOS (B√¥nus vs Pagos)
          const creditosBonus = userData.creditosBonus || 0;
          const creditosPagos = userData.creditosPagos || 0;
          const creditosTotal = userData.creditos || 0;
          
          if (creditosTotal > 0) {
            // Sempre desconta do total vis√≠vel
            updates.creditos = firebase.firestore.FieldValue.increment(-1);
            
            if (creditosBonus > 0) {
              // Tem b√¥nus? Desconta do b√¥nus (N√ÉO entra no pool)
              updates.creditosBonus = firebase.firestore.FieldValue.increment(-1);
              console.log(`üéÅ Descontando 1 cr√©dito b√¥nus (${creditosBonus - 1} restantes)`);
            } else if (creditosPagos > 0) {
              // N√£o tem b√¥nus? Desconta do pago (ENTRA no pool)
              updates.creditosPagos = firebase.firestore.FieldValue.increment(-1);
              updates[`creditosPagosJogo.${jogoId}`] = firebase.firestore.FieldValue.increment(1);
              console.log(`üíé Descontando 1 cr√©dito pago (${creditosPagos - 1} restantes) ‚Üí Entra no pool!`);
              
              // ‚úÖ Contabilizar no pool do jogo (s√≥ cr√©ditos pagos)
              await db.collection("jogos").doc(jogoId).update({
                poolCreditosPagos: firebase.firestore.FieldValue.increment(1)
              });
            }
          }
        }

        // Adicionar pontos se acertou (COM MULTIPLICADOR)
        if (acertou) {
          updates[`pontuacoes.${jogoId}`] = firebase.firestore.FieldValue.increment(pontosFinais);
          updates.xp = firebase.firestore.FieldValue.increment(pontosFinais);
          updates.maxStreak = Math.max(userData.maxStreak || 0, maxStreak);
          
          // ‚úÖ NOVO: Salvar tempo de resposta para desempate (s√≥ acertos)
          // Acumular soma dos tempos e quantidade para calcular m√©dia depois
          updates[`tempoRespostas.${jogoId}.soma`] = firebase.firestore.FieldValue.increment(tempoResposta);
          updates[`tempoRespostas.${jogoId}.quantidade`] = firebase.firestore.FieldValue.increment(1);
        }

        await db.collection("usuarios").doc(uid).update(updates);

        // Atualizar interface
        await updateFreePlays();
        await updateStats();
        await loadRanking();

        // üí∞ Verificar se deve mostrar patrocinador (a cada 5 respostas)
        verificarPatrocinador();

        // ‚úÖ FECHAR MODAL ap√≥s 3 segundos
        setTimeout(() => {
          currentQuestion = null;
          document.getElementById("btnAnswer").disabled = false;
          document.getElementById("btnAnswer").textContent = "üéØ Responder Pergunta";
          document.getElementById("questionModalOverlay").classList.remove("active");
        }, 3000);

      } catch (error) {
        console.error("‚ùå Erro ao processar resposta:", error);
        alert("Erro ao salvar resposta. Tente novamente!");
      }
    }

    // ===================================
    // üí¨ SISTEMA DE CHAT (CORRIGIDO!)
    // ===================================
    function switchChat(type) {
      const tabs = document.querySelectorAll(".chat-tab");
      const contents = document.querySelectorAll(".chat-content");

      tabs.forEach(tab => tab.classList.remove("active"));
      contents.forEach(content => content.classList.remove("active"));

      if (type === "team") {
        tabs[0].classList.add("active");
        document.getElementById("teamChatContent").classList.add("active");
      } else {
        tabs[1].classList.add("active");
        document.getElementById("generalChatContent").classList.add("active");
      }
    }

    // ‚úÖ VARI√ÅVEIS PARA LISTENERS DO CHAT
    let chatListener = null;

    function initChat() {
      console.log("üí¨ Iniciando chat em tempo real...");
      
      // Cancelar listener anterior se existir
      if (chatListener) {
        chatListener();
        chatListener = null;
      }
      
      // ‚úÖ LISTENER √öNICO E SIMPLES - Sem orderBy (n√£o precisa de √≠ndice!)
      chatListener = db.collection("chats")
        .where("jogoId", "==", jogoId)
        .limit(200)  // Limitar para melhor performance
        .onSnapshot({ includeMetadataChanges: false }, snapshot => {
          console.log("üì© Chat atualizado! Total:", snapshot.size);
          
          const msgsTorcida = [];
          const msgsGeral = [];
          
          snapshot.forEach(doc => {
            const data = doc.data();
            
            // Separar mensagens por tipo
            if (data.timeId === timeTorcida) {
              msgsTorcida.push(data);
            }
            if (!data.timeId || data.tipo === "geral") {
              msgsGeral.push(data);
            }
          });
          
          // Ordenar por timestamp no cliente
          const ordenarPorTempo = (a, b) => {
            const getTime = (msg) => {
              if (!msg.timestamp) return Date.now(); // Mensagens novas sem timestamp v√£o pro final
              if (msg.timestamp.toMillis) return msg.timestamp.toMillis();
              if (msg.timestamp.seconds) return msg.timestamp.seconds * 1000;
              return 0;
            };
            return getTime(a) - getTime(b);
          };
          
          msgsTorcida.sort(ordenarPorTempo);
          msgsGeral.sort(ordenarPorTempo);
          
          // Pegar apenas as √∫ltimas 50 mensagens de cada
          const ultimasTorcida = msgsTorcida.slice(-50);
          const ultimasGeral = msgsGeral.slice(-50);
          
          // Renderizar chat da torcida
          const containerTorcida = document.getElementById("teamChat");
          if (containerTorcida) {
            containerTorcida.innerHTML = "";
            ultimasTorcida.forEach(msg => renderMessage(msg, containerTorcida));
            containerTorcida.scrollTop = containerTorcida.scrollHeight;
          }
          
          // Renderizar chat geral
          const containerGeral = document.getElementById("generalChat");
          if (containerGeral) {
            containerGeral.innerHTML = "";
            ultimasGeral.forEach(msg => renderMessage(msg, containerGeral));
            containerGeral.scrollTop = containerGeral.scrollHeight;
          }
          
        }, error => {
          console.error("‚ùå Erro no chat:", error);
          showToast("‚ö†Ô∏è Erro ao carregar chat. Recarregue a p√°gina.");
        });

      // Enter para enviar
      const teamInput = document.getElementById("teamChatInput");
      const generalInput = document.getElementById("generalChatInput");
      
      if (teamInput) {
        teamInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage("team");
          }
        });
      }
      if (generalInput) {
        generalInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage("general");
          }
        });
      }
    }

    function renderMessage(msg, container) {
      const div = document.createElement("div");
      div.className = "chat-message";
      
      const displayName = msg.usuarioUnico || msg.usuario || msg.nome || "An√¥nimo";
      const avatar = msg.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random`;
      
      div.innerHTML = `
        <img src="${avatar}" alt="${displayName}" class="chat-avatar">
        <div class="chat-content-msg">
          <div class="chat-author">${displayName}</div>
          <div class="chat-text">${escapeHtml(msg.mensagem)}</div>
        </div>
      `;
      container.appendChild(div);
    }

    // Fun√ß√£o para escapar HTML e prevenir XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ‚úÖ Cache dos dados do usu√°rio para n√£o buscar toda vez
    let cachedUserData = null;
    
    async function sendMessage(type) {
      const inputId = type === "team" ? "teamChatInput" : "generalChatInput";
      const input = document.getElementById(inputId);
      const mensagem = input.value.trim();
      
      if (!mensagem) return;
      
      // ‚úÖ Limpar input IMEDIATAMENTE (feedback instant√¢neo)
      input.value = "";
      input.disabled = true;
      input.placeholder = "Enviando...";

      try {
        // ‚úÖ Usar cache se dispon√≠vel
        if (!cachedUserData) {
          const userDoc = await db.collection("usuarios").doc(uid).get();
          cachedUserData = userDoc.data() || {};
        }
        
        const user = cachedUserData;
        const displayName = user.usuarioUnico || user.usuario || user.nome || "An√¥nimo";
        const avatar = user.avatarUrl || user.avatar || user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random`;

        // ‚úÖ Enviar para o Firestore
        await db.collection("chats").add({
          jogoId,
          timeId: type === "team" ? timeTorcida : null,
          tipo: type === "team" ? "torcida" : "geral",
          userId: uid,
          usuario: user.usuario || null,
          usuarioUnico: user.usuarioUnico || null,
          nome: displayName,
          avatar,
          mensagem,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log("‚úÖ Mensagem enviada:", mensagem);

      } catch (error) {
        console.error("‚ùå Erro ao enviar mensagem:", error);
        // Restaurar mensagem se deu erro
        input.value = mensagem;
        showToast("‚ùå Erro ao enviar. Tente novamente!");
      } finally {
        // ‚úÖ Reativar input
        input.disabled = false;
        input.placeholder = type === "team" ? "Digite sua mensagem..." : "Mensagem para todos...";
        input.focus();
      }
    }

    // ===================================
    // üèÜ RANKING COM CR√âDITOS ESTIMADOS
    // ===================================
    
    // Pesos para distribui√ß√£o do ranking
    const PESOS_RANKING = [10, 7, 5, 4, 3, 2, 1.5, 1, 0.75, 0.5];
    const SOMA_PESOS = PESOS_RANKING.reduce((a, b) => a + b, 0); // 34.75
    
    // Vari√°veis globais para estat√≠sticas do jogo
    let totalCreditosPagosJogo = 0;
    let estatisticasTimes = { casa: { pontos: 0, torcedores: 0 }, fora: { pontos: 0, torcedores: 0 } };
    
    async function loadRanking() {
      try {
        const usuarios = await db.collection("usuarios").get();
        const ranking = [];
        
        // Reset estat√≠sticas
        totalCreditosPagosJogo = 0;
        estatisticasTimes = { 
          casa: { pontos: 0, torcedores: 0, nome: timeCasaData?.nome || 'Time A' }, 
          fora: { pontos: 0, torcedores: 0, nome: timeForaData?.nome || 'Time B' } 
        };

        usuarios.forEach(doc => {
          const user = doc.data();
          const odId = doc.id;
          const timeUser = user.torcidas?.[jogoId];
          
          // S√≥ usu√°rios deste jogo
          if (timeUser !== timeCasaId && timeUser !== timeForaId) return;
          
          // Contar torcedores
          if (timeUser === timeCasaId) {
            estatisticasTimes.casa.torcedores++;
          } else {
            estatisticasTimes.fora.torcedores++;
          }

          const pontos = user.pontuacoes?.[jogoId] || 0;
          
          // Somar cr√©ditos pagos neste jogo
          const creditosPagos = user.creditosPagosJogo?.[jogoId] || 0;
          totalCreditosPagosJogo += creditosPagos;
          
          // Somar pontos por time
          if (timeUser === timeCasaId) {
            estatisticasTimes.casa.pontos += pontos;
          } else {
            estatisticasTimes.fora.pontos += pontos;
          }
          
          if (pontos > 0) {
            const displayName = user.usuarioUnico || user.usuario || user.nome || "An√¥nimo";
            
            // Calcular tempo m√©dio de resposta
            const tempoData = user.tempoRespostas?.[jogoId];
            let tempoMedio = 10; // Default 10s se n√£o tiver dados
            if (tempoData && tempoData.quantidade > 0) {
              tempoMedio = tempoData.soma / tempoData.quantidade;
            }
            
            ranking.push({
              odId,
              nome: displayName,
              pontos,
              tempoMedio,
              timeId: timeUser,
              avatar: user.avatarUrl || user.avatar || user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random`
            });
          }
        });

        // ‚úÖ ORDENAR: Por pontos (desc), desempate por tempo m√©dio (asc = mais r√°pido)
        ranking.sort((a, b) => {
          if (b.pontos !== a.pontos) return b.pontos - a.pontos;
          return a.tempoMedio - b.tempoMedio; // Menor tempo = melhor
        });

        // Calcular cr√©ditos estimados
        const creditosEstimados = calcularCreditosEstimados(ranking.length);

        const rankingList = document.getElementById("rankingList");
        rankingList.innerHTML = "";

        if (ranking.length === 0) {
          rankingList.innerHTML = '<li style="text-align: center; color: var(--text-secondary); padding: 40px;">Nenhuma pontua√ß√£o ainda. Seja o primeiro!</li>';
          atualizarInfoPremiacao(0, 0, jogoCreditosIniciais);
          return;
        }

        ranking.slice(0, 10).forEach((user, index) => {
          const li = document.createElement("li");
          li.className = "ranking-item";
          
          const posicao = index + 1;
          const medalha = posicao === 1 ? 'ü•á' : posicao === 2 ? 'ü•à' : posicao === 3 ? 'ü•â' : `${posicao}¬∫`;
          
          // Cor do time
          const corTime = user.timeId === timeCasaId ? 'var(--cor-timeA)' : 'var(--cor-timeB)';
          
          // Cr√©ditos estimados para esta posi√ß√£o
          const creditos = creditosEstimados[index] || 0;
          const creditosDisplay = creditos > 0 ? `<span class="ranking-credits">+${creditos} üíé</span>` : '';
          
          li.innerHTML = `
            <span class="ranking-position">${medalha}</span>
            <img src="${user.avatar}" alt="${user.nome}" class="ranking-avatar">
            <div class="ranking-info">
              <span class="ranking-name" style="color: ${corTime}">${user.nome}</span>
              <span class="ranking-time">${user.tempoMedio.toFixed(1)}s avg</span>
            </div>
            <div class="ranking-stats">
              <span class="ranking-points">${user.pontos} pts</span>
              ${creditosDisplay}
            </div>
          `;
          
          rankingList.appendChild(li);
        });
        
        // Atualizar info de premia√ß√£o (inclui cr√©ditos do admin)
        atualizarInfoPremiacao(totalCreditosPagosJogo, ranking.length, jogoCreditosIniciais);

      } catch (error) {
        console.error("‚ùå Erro ao carregar ranking:", error);
      }
    }
    
    // Calcular cr√©ditos estimados para cada posi√ß√£o
    function calcularCreditosEstimados(totalParticipantes) {
      if (totalCreditosPagosJogo <= 0 || totalParticipantes <= 0) {
        return []; // Sem cr√©ditos ou participantes
      }
      
      // NOVA DISTRIBUI√á√ÉO:
      // 5% fundo, 50% ranking, 10% sortudo vencedor, 5% sortudo popular, 30% cotistas
      const totalRanking = Math.floor(totalCreditosPagosJogo * 0.50); // 50% do total
      
      // Premiar at√© 100 colocados
      let quantosPremiar = Math.min(100, totalParticipantes);
      
      // Calcular pesos (distribui√ß√£o decrescente)
      const pesos = [];
      for (let i = 0; i < quantosPremiar; i++) {
        pesos.push(Math.max(1, 100 - i));
      }
      const somaPesos = pesos.reduce((a, b) => a + b, 0);
      
      // Distribuir cr√©ditos
      const creditos = [];
      let distribuido = 0;
      
      for (let i = 0; i < quantosPremiar; i++) {
        const valor = Math.floor(totalRanking * pesos[i] / somaPesos);
        creditos.push(Math.max(1, valor)); // M√≠nimo 1 cr√©dito
        distribuido += valor;
      }
      
      // Sobra vai pro primeiro
      if (creditos.length > 0) {
        creditos[0] += (totalRanking - distribuido);
      }
      
      return creditos;
    }
    
    // Atualizar info de premia√ß√£o na interface
    function atualizarInfoPremiacao(totalCreditos, totalParticipantes, creditosAdmin = 0) {
      const infoEl = document.getElementById("premiacaoInfo");
      if (!infoEl) return;
      
      const totalPote = totalCreditos + creditosAdmin;
      
      if (totalPote > 0) {
        let adminInfo = creditosAdmin > 0 ? ` <small style="color: #2ecc71;">(+${creditosAdmin} b√¥nus)</small>` : '';
        infoEl.innerHTML = `
          <div class="premiacao-ativa">
            üèÜ <strong>${totalPote}</strong> cr√©ditos em jogo!${adminInfo}
          </div>
        `;
      } else {
        infoEl.innerHTML = `
          <div class="premiacao-ativa">
            üèÜ <strong>0</strong> cr√©ditos em jogo!
          </div>
        `;
      }
    }
    
    // ===================================
    // üèÜ PREMIA√á√ÉO AUTOM√ÅTICA
    // ===================================
    
    async function executarPremiacao() {
      // Evitar executar m√∫ltiplas vezes
      if (premiacaoExecutada) {
        console.log("‚ö†Ô∏è Premia√ß√£o j√° foi executada");
        return;
      }
      
      console.log("üèÜ Iniciando premia√ß√£o autom√°tica...");
      
      try {
        // Verificar se o jogo j√° foi premiado
        const jogoDoc = await db.collection("jogos").doc(jogoId).get();
        const jogoData = jogoDoc.data();
        
        if (jogoData.premiado) {
          console.log("‚úÖ Jogo j√° foi premiado anteriormente");
          premiacaoExecutada = true;
          mostrarResultadoPremiacao(jogoData.premiacaoDetalhes);
          return;
        }
        
        // Buscar todos os usu√°rios do jogo
        const usuarios = await db.collection("usuarios").get();
        const participantes = [];
        let totalCreditosPagos = 0;
        let totalCreditosUsados = 0; // NOVO: Cr√©ditos totais usados (pagos + b√¥nus)
        
        const estatisticas = {
          timeCasa: { pontos: 0, torcedores: [], nome: timeCasaData?.nome },
          timeFora: { pontos: 0, torcedores: [], nome: timeForaData?.nome }
        };
        
        usuarios.forEach(doc => {
          const user = doc.data();
          const odId = doc.id;
          const timeUser = user.torcidas?.[jogoId];
          
          if (timeUser !== timeCasaId && timeUser !== timeForaId) return;
          
          const pontos = user.pontuacoes?.[jogoId] || 0;
          const creditosPagos = user.creditosPagosJogo?.[jogoId] || 0;
          const totalRespostas = user.contadorRespostas?.[jogoId] || 0;
          const creditosUsadosUsuario = Math.max(0, totalRespostas - 5); // NOVO: Descontar 5 gr√°tis
          
          totalCreditosPagos += creditosPagos;
          totalCreditosUsados += creditosUsadosUsuario; // NOVO
          
          // Calcular tempo m√©dio
          const tempoData = user.tempoRespostas?.[jogoId];
          let tempoMedio = 10;
          if (tempoData && tempoData.quantidade > 0) {
            tempoMedio = tempoData.soma / tempoData.quantidade;
          }
          
          const nome = user.usuarioUnico || user.usuario || user.nome || "An√¥nimo";
          
          // Adicionar aos participantes se tiver pontos
          if (pontos > 0) {
            participantes.push({ odId, nome, pontos, tempoMedio, timeId: timeUser, creditosUsados: creditosUsadosUsuario });
          }
          
          // Estat√≠sticas por time
          if (timeUser === timeCasaId) {
            estatisticas.timeCasa.pontos += pontos;
            estatisticas.timeCasa.torcedores.push({ odId, nome });
          } else {
            estatisticas.timeFora.pontos += pontos;
            estatisticas.timeFora.torcedores.push({ odId, nome });
          }
        });
        
        console.log(`üí∞ Total cr√©ditos PAGOS: ${totalCreditosPagos}`);
        console.log(`üíµ Total cr√©ditos USADOS (pagos+b√¥nus): ${totalCreditosUsados}`);
        console.log(`üë• Total participantes com pontos: ${participantes.length}`);
        
        // Ordenar participantes por pontos e tempo
        participantes.sort((a, b) => {
          if (b.pontos !== a.pontos) return b.pontos - a.pontos;
          return a.tempoMedio - b.tempoMedio;
        });
        
        // ===== NOVA L√ìGICA: CR√âDITOS PARA TOP 100 + YC PARA TOP 10 =====
        const YC_POR_CREDITO = 2;
        
        // Pool de YC (s√≥ cr√©ditos PAGOS)
        const totalPoolYC = totalCreditosPagos * YC_POR_CREDITO;
        
        // Pool de cr√©ditos normais (pagos + b√¥nus)
        const totalPoolCreditos = totalCreditosUsados;
        
        // DISTRIBUI√á√ÉO YC: 5% fundo final ano, 50% ranking (top 10), 10% sortudo vencedor, 5% sortudo popular, 30% cotistas
        const fundoFinalAnoYC = parseFloat((totalPoolYC * 0.05).toFixed(2));  // 5% Fundo Final de Ano
        const totalRankingYC = parseFloat((totalPoolYC * 0.50).toFixed(2));   // 50% Ranking
        const totalSortudoVencedorYC = parseFloat((totalPoolYC * 0.10).toFixed(2)); // 10% Sortudo Vencedor
        const totalSortudoPopularYC = parseFloat((totalPoolYC * 0.05).toFixed(2));  // 5% Sortudo Popular
        const totalCotistasYC = parseFloat((totalPoolYC * 0.30).toFixed(2));  // 30% Cotistas Bolsa
        
        // DISTRIBUI√á√ÉO CR√âDITOS: 100% para ranking e sortudos
        const totalRankingCreditos = Math.floor(totalPoolCreditos * 0.85); // 85% ranking
        const totalSortudoCreditos = Math.floor(totalPoolCreditos * 0.15); // 15% sortudos
        
        console.log(`üí∞ Pool YC (pagos): ${totalPoolYC} YC`);
        console.log(`üíµ Pool Cr√©ditos (total): ${totalPoolCreditos} cr`);
        console.log(`üèÜ Fundo Final Ano: ${fundoFinalAnoYC} YC (5%)`);
        console.log(`üèÖ Ranking: ${totalRankingYC} YC (50%) / ${totalRankingCreditos} cr (85%)`);
        console.log(`üìà Cotistas: ${totalCotistasYC} YC (30%)`);
        console.log(`üé∞ Sortudos: ${totalSortudoVencedorYC + totalSortudoPopularYC} YC (15%) / ${totalSortudoCreditos} cr (15%)`);
        
        
        // ===== CALCULAR PR√äMIOS DO RANKING =====
        // Top 10: ganham YC + Cr√©ditos | Top 11-100: ganham s√≥ Cr√©ditos
        const PESOS_TOP10 = [25, 18, 14, 11, 9, 7, 6, 5, 3, 2]; // 100%
        const somaPesosTop10 = PESOS_TOP10.reduce((a, b) => a + b, 0);
        
        // Pesos para top 100 (distribui√ß√£o decrescente)
        const PESOS_TOP100 = [];
        for (let i = 0; i < 100; i++) {
          PESOS_TOP100.push(Math.max(1, 100 - i)); // 100, 99, 98... 1
        }
        const somaPesosTop100 = PESOS_TOP100.reduce((a, b) => a + b, 0);
        
        const quantosPremiarCreditos = Math.min(100, participantes.length);
        const quantosPremiarYC = Math.min(10, participantes.length);
        
        const premiosRanking = [];
        
        for (let i = 0; i < quantosPremiarCreditos; i++) {
          // Cr√©ditos para top 100
          const creditos = Math.floor(totalRankingCreditos * PESOS_TOP100[i] / somaPesosTop100);
          
          // YC s√≥ para top 10
          let yc = 0;
          if (i < 10 && totalPoolYC > 0) {
            yc = parseFloat((totalRankingYC * PESOS_TOP10[i] / somaPesosTop10).toFixed(2));
          }
          
          premiosRanking.push({
            ...participantes[i],
            posicao: i + 1,
            yc: yc,
            creditos: Math.max(1, creditos) // M√≠nimo 1 cr√©dito
          });
        }
        
        // ===== SORTEAR VENCEDOR (time com mais pontos) =====
        let timeVencedor = estatisticas.timeCasa;
        let timePopular = estatisticas.timeCasa;
        
        if (estatisticas.timeFora.pontos > estatisticas.timeCasa.pontos) {
          timeVencedor = estatisticas.timeFora;
        } else if (estatisticas.timeFora.pontos === estatisticas.timeCasa.pontos) {
          // Empate: sortear
          timeVencedor = Math.random() < 0.5 ? estatisticas.timeCasa : estatisticas.timeFora;
        }
        
        // Time com mais torcedores
        if (estatisticas.timeFora.torcedores.length > estatisticas.timeCasa.torcedores.length) {
          timePopular = estatisticas.timeFora;
        } else if (estatisticas.timeFora.torcedores.length === estatisticas.timeCasa.torcedores.length) {
          // Empate: sortear
          timePopular = Math.random() < 0.5 ? estatisticas.timeCasa : estatisticas.timeFora;
        }
        
        // Sortear pessoa do time vencedor
        let sortudoVencedor = null;
        const creditosSortudoVencedor = Math.floor(totalSortudoCreditos * 0.67); // 10% do total (67% dos 15%)
        const creditosSortudoPopular = totalSortudoCreditos - creditosSortudoVencedor; // 5% do total (33% dos 15%)
        
        if (timeVencedor.torcedores.length > 0) {
          const indice = Math.floor(Math.random() * timeVencedor.torcedores.length);
          sortudoVencedor = {
            ...timeVencedor.torcedores[indice],
            yc: totalSortudoVencedorYC,
            creditos: creditosSortudoVencedor,
            time: timeVencedor.nome
          };
        }
        
        // Sortear pessoa do time popular
        let sortudoPopular = null;
        if (timePopular.torcedores.length > 0) {
          const indice = Math.floor(Math.random() * timePopular.torcedores.length);
          sortudoPopular = {
            ...timePopular.torcedores[indice],
            yc: totalSortudoPopularYC,
            creditos: creditosSortudoPopular,
            time: timePopular.nome
          };
        }
        
        // ===== DISTRIBUIR PR√äMIOS (YC + Cr√©ditos) =====
        const batch = db.batch();
        
        // Ranking: Cr√©ditos para top 100 + YC para top 10
        for (const premio of premiosRanking) {
          const userRef = db.collection("usuarios").doc(premio.odId);
          const updates = {};
          
          // Cr√©ditos para todos do top 100
          if (premio.creditos > 0) {
            updates.creditos = firebase.firestore.FieldValue.increment(premio.creditos);
            updates.creditosBonus = firebase.firestore.FieldValue.increment(premio.creditos);
          }
          
          // YC s√≥ para top 10
          if (premio.yc > 0) {
            updates.yc = firebase.firestore.FieldValue.increment(premio.yc);
          }
          
          if (Object.keys(updates).length > 0) {
            batch.update(userRef, updates);
            console.log(`üèÖ ${premio.nome} (${premio.posicao}¬∫): +${premio.creditos} cr${premio.yc > 0 ? ` + ${premio.yc} YC` : ''}`);
          }
        }
        
        // Sortudo vencedor (YC + Cr√©ditos)
        if (sortudoVencedor) {
          const userRef = db.collection("usuarios").doc(sortudoVencedor.odId);
          const updates = {};
          if (sortudoVencedor.yc > 0) {
            updates.yc = firebase.firestore.FieldValue.increment(sortudoVencedor.yc);
          }
          if (sortudoVencedor.creditos > 0) {
            updates.creditos = firebase.firestore.FieldValue.increment(sortudoVencedor.creditos);
            updates.creditosBonus = firebase.firestore.FieldValue.increment(sortudoVencedor.creditos);
          }
          if (Object.keys(updates).length > 0) {
            batch.update(userRef, updates);
            console.log(`üé∞ ${sortudoVencedor.nome}: +${sortudoVencedor.creditos} cr${sortudoVencedor.yc > 0 ? ` + ${sortudoVencedor.yc} YC` : ''} (Sortudo Vencedor)`);
          }
        }
        
        // Sortudo popular (YC + Cr√©ditos)
        if (sortudoPopular) {
          const userRef = db.collection("usuarios").doc(sortudoPopular.odId);
          const updates = {};
          if (sortudoPopular.yc > 0) {
            updates.yc = firebase.firestore.FieldValue.increment(sortudoPopular.yc);
          }
          if (sortudoPopular.creditos > 0) {
            updates.creditos = firebase.firestore.FieldValue.increment(sortudoPopular.creditos);
            updates.creditosBonus = firebase.firestore.FieldValue.increment(sortudoPopular.creditos);
          }
          if (Object.keys(updates).length > 0) {
            batch.update(userRef, updates);
            console.log(`üçÄ ${sortudoPopular.nome}: +${sortudoPopular.creditos} cr${sortudoPopular.yc > 0 ? ` + ${sortudoPopular.yc} YC` : ''} (Sortudo Popular)`);
          }
        }
        
        // ===== DISTRIBUIR PARA COTISTAS DA BOLSA (25%) EM YC =====
        let cotistasPremiados = [];
        let cotasCasa = [];
        let cotasFora = [];
        let totalCotasCasa = 0;
        let totalCotasFora = 0;
        let premioCotasCasaYC = 0;
        let premioCotasForaYC = 0;
        
        // Buscar cotas dos times (necess√°rio tamb√©m para varia√ß√£o de pre√ßo)
        try {
          const cotasCasaSnapshot = await db.collection("bolsa_cotas")
            .where("timeId", "==", timeCasaId)
            .get();
          
          const cotasForaSnapshot = await db.collection("bolsa_cotas")
            .where("timeId", "==", timeForaId)
            .get();
          
          cotasCasaSnapshot.forEach(doc => {
            const cota = doc.data();
            cotasCasa.push({ odId: cota.userId, odNome: cota.usuarioNome, quantidade: cota.quantidade || 0 });
            totalCotasCasa += cota.quantidade || 0;
          });
          
          cotasForaSnapshot.forEach(doc => {
            const cota = doc.data();
            cotasFora.push({ odId: cota.userId, odNome: cota.usuarioNome, quantidade: cota.quantidade || 0 });
            totalCotasFora += cota.quantidade || 0;
          });
          
          // Determinar time vencedor da partida (pelo resultado real ou por pontos)
          let percentualCasa = 0.5;  // Empate padr√£o
          let percentualFora = 0.5;
          
          if (estatisticas.timeCasa.pontos > estatisticas.timeFora.pontos) {
            percentualCasa = 0.7;  // Time casa venceu: 70%
            percentualFora = 0.3;  // Time fora: 30%
          } else if (estatisticas.timeFora.pontos > estatisticas.timeCasa.pontos) {
            percentualCasa = 0.3;  // Time casa: 30%
            percentualFora = 0.7;  // Time fora venceu: 70%
          }
          
          premioCotasCasaYC = parseFloat((totalCotistasYC * percentualCasa).toFixed(2));
          premioCotasForaYC = parseFloat((totalCotistasYC * percentualFora).toFixed(2));
          
          // Calcular YC por cota para verificar m√≠nimo
          const ycPorCotaCasa = totalCotasCasa > 0 ? premioCotasCasaYC / totalCotasCasa : 0;
          const ycPorCotaFora = totalCotasFora > 0 ? premioCotasForaYC / totalCotasFora : 0;
          
          console.log(`üìà Cotistas Casa: ${premioCotasCasaYC} YC (${ycPorCotaCasa.toFixed(4)} YC/cota)`);
          console.log(`üìà Cotistas Fora: ${premioCotasForaYC} YC (${ycPorCotaFora.toFixed(4)} YC/cota)`);
          
          // Distribuir para cotistas do time da casa (s√≥ se >= 0.01 YC por cota)
          if (totalCotasCasa > 0 && ycPorCotaCasa >= 0.01) {
            for (const cotista of cotasCasa) {
              if (cotista.quantidade > 0) {
                const ycCotista = parseFloat((ycPorCotaCasa * cotista.quantidade).toFixed(2));
                
                if (ycCotista >= 0.01) {
                  const userRef = db.collection("usuarios").doc(cotista.odId);
                  batch.update(userRef, {
                    yc: firebase.firestore.FieldValue.increment(ycCotista)
                  });
                  cotistasPremiados.push({
                    odId: cotista.odId,
                    nome: cotista.odNome,
                    yc: ycCotista,
                    time: estatisticas.timeCasa.nome,
                    cotas: cotista.quantidade
                  });
                  console.log(`üìà ${cotista.odNome}: +${ycCotista} YC (${cotista.quantidade} cotas ${estatisticas.timeCasa.nome})`);
                }
              }
            }
          } else if (totalCotasCasa > 0) {
            console.log(`‚ö†Ô∏è YC por cota casa (${ycPorCotaCasa.toFixed(4)}) < 0.01 - n√£o distribui`);
          }
          
          // Distribuir para cotistas do time de fora (s√≥ se >= 0.01 YC por cota)
          if (totalCotasFora > 0 && ycPorCotaFora >= 0.01) {
            for (const cotista of cotasFora) {
              if (cotista.quantidade > 0) {
                const ycCotista = parseFloat((ycPorCotaFora * cotista.quantidade).toFixed(2));
                
                if (ycCotista >= 0.01) {
                  const userRef = db.collection("usuarios").doc(cotista.odId);
                  batch.update(userRef, {
                    yc: firebase.firestore.FieldValue.increment(ycCotista)
                  });
                  cotistasPremiados.push({
                    odId: cotista.odId,
                    nome: cotista.odNome,
                    yc: ycCotista,
                    time: estatisticas.timeFora.nome,
                    cotas: cotista.quantidade
                  });
                  console.log(`üìà ${cotista.odNome}: +${ycCotista} YC (${cotista.quantidade} cotas ${estatisticas.timeFora.nome})`);
                }
              }
            }
          } else if (totalCotasFora > 0) {
            console.log(`‚ö†Ô∏è YC por cota fora (${ycPorCotaFora.toFixed(4)}) < 0.01 - n√£o distribui`);
          }
          
        } catch (e) {
          console.error("Erro ao distribuir para cotistas:", e);
        }
        
        // Marcar jogo como premiado
        const premiacaoDetalhes = {
          totalCreditosPagos: totalCreditosPagos,
          totalCreditosUsados: totalCreditosUsados,
          totalPoolYC: totalPoolYC,
          totalPoolCreditos: totalPoolCreditos,
          fundoFinalAnoYC: fundoFinalAnoYC,
          totalRankingYC: totalRankingYC,
          totalRankingCreditos: totalRankingCreditos,
          totalCotistasYC: totalCotistasYC,
          ranking: premiosRanking,
          sortudoVencedor,
          sortudoPopular,
          cotistas: cotistasPremiados,
          estatisticas: {
            timeCasa: { nome: estatisticas.timeCasa.nome, pontos: estatisticas.timeCasa.pontos, torcedores: estatisticas.timeCasa.torcedores.length },
            timeFora: { nome: estatisticas.timeFora.nome, pontos: estatisticas.timeFora.pontos, torcedores: estatisticas.timeFora.torcedores.length }
          }
        };
        
        const jogoRef = db.collection("jogos").doc(jogoId);
        batch.update(jogoRef, {
          premiado: true,
          premiacaoData: firebase.firestore.FieldValue.serverTimestamp(),
          premiacaoDetalhes
        });
        
        // ===== üèÜ ACUMULAR FUNDO FINAL DE ANO =====
        if (fundoFinalAnoYC > 0) {
          const fundoRef = db.collection("bolsa_config").doc("fundo_final_ano");
          batch.set(fundoRef, {
            totalAcumulado: firebase.firestore.FieldValue.increment(fundoFinalAnoYC),
            ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp(),
            historico: firebase.firestore.FieldValue.arrayUnion({
              jogoId: jogoId,
              valor: fundoFinalAnoYC,
              data: new Date().toISOString()
            })
          }, { merge: true });
          console.log(`üèÜ Fundo Final de Ano: +${fundoFinalAnoYC} YC acumulado`);
        }
        
        // ===== üìà ATUALIZAR PRE√áOS DOS TIMES NA BOLSA (SEMPRE EXECUTA) =====
        try {
          console.log("üìà Atualizando pre√ßos da bolsa...");
          
          // Configura√ß√£o de valoriza√ß√£o
          const VALORIZACAO = {
            porVitoriaPontuacao: 3,      // +3% se venceu em pontos
            porVitoriaTorcida: 2,        // +2% se venceu em torcedores
            porDerrotaPontuacao: -2,     // -2% se perdeu em pontos
            porDerrotaTorcida: -1.5,     // -1.5% se perdeu em torcedores
            porJogo: 0.5,                // +0.5% s√≥ por jogar
            porPonto: 0.005,             // +0.005% por ponto feito pela torcida
            porTorcedor: 0.05,           // +0.05% por torcedor
            maxVariacao: 15              // M√°ximo ¬±15% por jogo
          };
          
          // Buscar m√©tricas atuais dos times
          const metricaCasaDoc = await db.collection("bolsa_metricas_time").doc(timeCasaId).get();
          const metricaForaDoc = await db.collection("bolsa_metricas_time").doc(timeForaId).get();
          
          const metricaCasa = metricaCasaDoc.exists ? metricaCasaDoc.data() : { precoAlgoritmo: 500, mediaDividendos: 0 };
          const metricaFora = metricaForaDoc.exists ? metricaForaDoc.data() : { precoAlgoritmo: 500, mediaDividendos: 0 };
          
          // Calcular varia√ß√£o para TIME DA CASA
          let variacaoCasa = VALORIZACAO.porJogo; // Base: jogou = +0.5%
          variacaoCasa += estatisticas.timeCasa.pontos * VALORIZACAO.porPonto;
          variacaoCasa += estatisticas.timeCasa.torcedores.length * VALORIZACAO.porTorcedor;
          
          if (estatisticas.timeCasa.pontos > estatisticas.timeFora.pontos) {
            variacaoCasa += VALORIZACAO.porVitoriaPontuacao;
          } else if (estatisticas.timeCasa.pontos < estatisticas.timeFora.pontos) {
            variacaoCasa += VALORIZACAO.porDerrotaPontuacao;
          }
          
          if (estatisticas.timeCasa.torcedores.length > estatisticas.timeFora.torcedores.length) {
            variacaoCasa += VALORIZACAO.porVitoriaTorcida;
          } else if (estatisticas.timeCasa.torcedores.length < estatisticas.timeFora.torcedores.length) {
            variacaoCasa += VALORIZACAO.porDerrotaTorcida;
          }
          
          variacaoCasa = Math.max(-VALORIZACAO.maxVariacao, Math.min(VALORIZACAO.maxVariacao, variacaoCasa));
          
          // Calcular varia√ß√£o para TIME DE FORA
          let variacaoFora = VALORIZACAO.porJogo;
          variacaoFora += estatisticas.timeFora.pontos * VALORIZACAO.porPonto;
          variacaoFora += estatisticas.timeFora.torcedores.length * VALORIZACAO.porTorcedor;
          
          if (estatisticas.timeFora.pontos > estatisticas.timeCasa.pontos) {
            variacaoFora += VALORIZACAO.porVitoriaPontuacao;
          } else if (estatisticas.timeFora.pontos < estatisticas.timeCasa.pontos) {
            variacaoFora += VALORIZACAO.porDerrotaPontuacao;
          }
          
          if (estatisticas.timeFora.torcedores.length > estatisticas.timeCasa.torcedores.length) {
            variacaoFora += VALORIZACAO.porVitoriaTorcida;
          } else if (estatisticas.timeFora.torcedores.length < estatisticas.timeCasa.torcedores.length) {
            variacaoFora += VALORIZACAO.porDerrotaTorcida;
          }
          
          variacaoFora = Math.max(-VALORIZACAO.maxVariacao, Math.min(VALORIZACAO.maxVariacao, variacaoFora));
          
          // Calcular novos pre√ßos (m√≠nimo 1 cr)
          const precoFinalCasa = Math.max(1, Math.round(metricaCasa.precoAlgoritmo * (1 + variacaoCasa / 100)));
          const precoFinalFora = Math.max(1, Math.round(metricaFora.precoAlgoritmo * (1 + variacaoFora / 100)));
          
          // Calcular dividendo por cota (YC distribu√≠do / total de cotas)
          const dividendoPorCotaCasa = totalCotasCasa > 0 ? premioCotasCasaYC / totalCotasCasa : 0;
          const dividendoPorCotaFora = totalCotasFora > 0 ? premioCotasForaYC / totalCotasFora : 0;
          
          // Nova m√©dia de dividendos (m√©dia m√≥vel 10 jogos)
          const jogosParaMedia = 10;
          const novaDividendoMediaCasa = ((metricaCasa.mediaDividendos || 0) * (jogosParaMedia - 1) + dividendoPorCotaCasa) / jogosParaMedia;
          const novaDividendoMediaFora = ((metricaFora.mediaDividendos || 0) * (jogosParaMedia - 1) + dividendoPorCotaFora) / jogosParaMedia;
          
          console.log(`üìä ${estatisticas.timeCasa.nome}: ${metricaCasa.precoAlgoritmo} ‚Üí ${precoFinalCasa} cr (${variacaoCasa >= 0 ? '+' : ''}${variacaoCasa.toFixed(2)}%)`);
          console.log(`üìä ${estatisticas.timeFora.nome}: ${metricaFora.precoAlgoritmo} ‚Üí ${precoFinalFora} cr (${variacaoFora >= 0 ? '+' : ''}${variacaoFora.toFixed(2)}%)`);
          
          // Atualizar m√©tricas do time da casa
          batch.set(db.collection("bolsa_metricas_time").doc(timeCasaId), {
            timeId: timeCasaId,
            timeNome: estatisticas.timeCasa.nome,
            precoAlgoritmo: precoFinalCasa,
            precoMercado: precoFinalCasa,
            variacaoDia: variacaoCasa,
            mediaDividendos: parseFloat(novaDividendoMediaCasa.toFixed(4)),
            ultimaDividendo: dividendoPorCotaCasa,
            ultimoJogoId: jogoId,
            ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          // Atualizar m√©tricas do time de fora
          batch.set(db.collection("bolsa_metricas_time").doc(timeForaId), {
            timeId: timeForaId,
            timeNome: estatisticas.timeFora.nome,
            precoAlgoritmo: precoFinalFora,
            precoMercado: precoFinalFora,
            variacaoDia: variacaoFora,
            mediaDividendos: parseFloat(novaDividendoMediaFora.toFixed(4)),
            ultimaDividendo: dividendoPorCotaFora,
            ultimoJogoId: jogoId,
            ultimaAtualizacao: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          // Registrar dividendos no hist√≥rico
          batch.set(db.collection("bolsa_dividendos").doc(), {
            jogoId: jogoId,
            dataJogo: firebase.firestore.FieldValue.serverTimestamp(),
            times: {
              [timeCasaId]: {
                nome: estatisticas.timeCasa.nome,
                dividendoPorCota: dividendoPorCotaCasa,
                totalDistribuido: premioCotasCasaYC,
                totalCotas: totalCotasCasa,
                pontosTorcida: estatisticas.timeCasa.pontos,
                numTorcedores: estatisticas.timeCasa.torcedores.length,
                variacaoPreco: variacaoCasa,
                precoAnterior: metricaCasa.precoAlgoritmo,
                precoNovo: precoFinalCasa
              },
              [timeForaId]: {
                nome: estatisticas.timeFora.nome,
                dividendoPorCota: dividendoPorCotaFora,
                totalDistribuido: premioCotasForaYC,
                totalCotas: totalCotasFora,
                pontosTorcida: estatisticas.timeFora.pontos,
                numTorcedores: estatisticas.timeFora.torcedores.length,
                variacaoPreco: variacaoFora,
                precoAnterior: metricaFora.precoAlgoritmo,
                precoNovo: precoFinalFora
              }
            }
          });
          
          // Adicionar info da bolsa nos detalhes
          premiacaoDetalhes.bolsa = {
            timeCasa: { precoAnterior: metricaCasa.precoAlgoritmo, precoNovo: precoFinalCasa, variacao: variacaoCasa, dividendoPorCota: dividendoPorCotaCasa },
            timeFora: { precoAnterior: metricaFora.precoAlgoritmo, precoNovo: precoFinalFora, variacao: variacaoFora, dividendoPorCota: dividendoPorCotaFora }
          };
          
          console.log("‚úÖ Pre√ßos da bolsa atualizados!");
          
        } catch (bolsaError) {
          console.error("‚ùå Erro ao atualizar pre√ßos da bolsa:", bolsaError);
        }
        
        // Executar batch
        await batch.commit();
        
        premiacaoExecutada = true;
        console.log("‚úÖ Premia√ß√£o executada com sucesso!");
        
        // Mostrar resultado
        mostrarResultadoPremiacao(premiacaoDetalhes);
        
      } catch (error) {
        console.error("‚ùå Erro na premia√ß√£o:", error);
        showToast("‚ùå Erro ao processar premia√ß√£o");
      }
    }
    
    // Mostrar resultado da premia√ß√£o
    function mostrarResultadoPremiacao(detalhes) {
      if (!detalhes || detalhes.semPremiacao) {
        return;
      }
      
      // Criar modal de resultado
      const modal = document.createElement("div");
      modal.className = "premiacao-modal-overlay";
      modal.innerHTML = `
        <div class="premiacao-modal">
          <h2>üèÜ RESULTADO DA PREMIA√á√ÉO</h2>
          
          <div class="premiacao-total">
            üí∞ Total em jogo: <strong>${detalhes.totalPago}</strong> cr√©ditos
            <br><small>Taxa Yellup: ${detalhes.taxaCasa} cr√©ditos (20%)</small>
          </div>
          
          <div class="premiacao-secao">
            <h3>üèÖ Ranking</h3>
            <ul class="premiacao-lista">
              ${detalhes.ranking.map(p => `
                <li>
                  <span>${p.posicao === 1 ? 'ü•á' : p.posicao === 2 ? 'ü•à' : p.posicao === 3 ? 'ü•â' : p.posicao + '¬∫'} ${p.nome}</span>
                  <span>+${p.creditos} üíé</span>
                </li>
              `).join('')}
            </ul>
          </div>
          
          <div class="premiacao-sorteios">
            <div class="premiacao-sortudo">
              <h4>üé∞ Sortudo Vencedor</h4>
              <p>${detalhes.sortudoVencedor?.nome || 'N/A'}</p>
              <span>+${detalhes.sortudoVencedor?.creditos || 0} üíé</span>
              <small>Time: ${detalhes.sortudoVencedor?.time || 'N/A'}</small>
            </div>
            <div class="premiacao-sortudo">
              <h4>üçÄ Sortudo Popular</h4>
              <p>${detalhes.sortudoPopular?.nome || 'N/A'}</p>
              <span>+${detalhes.sortudoPopular?.creditos || 0} üíé</span>
              <small>Time: ${detalhes.sortudoPopular?.time || 'N/A'}</small>
            </div>
          </div>
          
          <button class="btn-fechar-premiacao" onclick="this.closest('.premiacao-modal-overlay').remove()">
            Fechar
          </button>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Verificar se o usu√°rio atual ganhou algo
      verificarPremioUsuario(detalhes);
    }
    
    // Criar confetes
    function criarConfetes() {
      const cores = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ff8c42', '#a78bfa'];
      const confeteContainer = document.createElement('div');
      confeteContainer.id = 'confeteContainer';
      document.body.appendChild(confeteContainer);
      
      for (let i = 0; i < 100; i++) {
        setTimeout(() => {
          const confete = document.createElement('div');
          confete.className = 'confete';
          confete.style.cssText = `
            left: ${Math.random() * 100}vw;
            background: ${cores[Math.floor(Math.random() * cores.length)]};
            width: ${Math.random() * 10 + 5}px;
            height: ${Math.random() * 10 + 5}px;
            border-radius: ${Math.random() > 0.5 ? '50%' : '0'};
            animation: confeteFall ${Math.random() * 2 + 2}s linear forwards;
          `;
          confeteContainer.appendChild(confete);
          
          // Remover ap√≥s anima√ß√£o
          setTimeout(() => confete.remove(), 4000);
        }, i * 30);
      }
      
      // Limpar container ap√≥s 5s
      setTimeout(() => confeteContainer.remove(), 5000);
    }
    
    // Mostrar anima√ß√£o de vit√≥ria
    function mostrarAnimacaoVitoria(posicao, creditos, tipo) {
      // Criar confetes primeiro
      criarConfetes();
      
      // Determinar medalha baseada na posi√ß√£o
      let medalha = 'üéñÔ∏è';
      let textoTipo = 'Premia√ß√£o';
      
      if (tipo === 'ranking') {
        if (posicao === 1) medalha = 'ü•á';
        else if (posicao === 2) medalha = 'ü•à';
        else if (posicao === 3) medalha = 'ü•â';
        else if (posicao <= 10) medalha = 'üèÖ';
        else medalha = 'üéñÔ∏è';
        textoTipo = `${posicao}¬∫ Lugar no Ranking!`;
      } else if (tipo === 'sortudo_vencedor') {
        medalha = 'üé∞';
        textoTipo = 'Sortudo Vencedor!';
      } else if (tipo === 'sortudo_popular') {
        medalha = 'üçÄ';
        textoTipo = 'Sortudo Popular!';
      }
      
      const overlay = document.createElement('div');
      overlay.className = 'vitoria-overlay';
      overlay.innerHTML = `
        <div class="vitoria-modal">
          <div class="vitoria-medalha">${medalha}</div>
          <div class="vitoria-posicao">${textoTipo}</div>
          <div class="vitoria-texto">Parab√©ns! Voc√™ foi premiado!</div>
          <div class="vitoria-premio">
            <div>
              <div class="vitoria-premio-valor">+${creditos}</div>
              <div class="vitoria-premio-tipo">cr√©ditos</div>
            </div>
          </div>
          <button class="vitoria-btn" onclick="this.closest('.vitoria-overlay').remove()">
            üéâ Celebrar!
          </button>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      // Som de vit√≥ria (opcional - descomente se quiser)
      // new Audio('som-vitoria.mp3').play().catch(e => {});
    }
    
    // Verificar se o usu√°rio atual ganhou
    function verificarPremioUsuario(detalhes) {
      let premioTotal = 0;
      let posicaoRanking = null;
      let tipoPremiacao = null;
      
      // Verificar ranking
      const premioRanking = detalhes.ranking.find(p => p.odId === uid);
      if (premioRanking) {
        premioTotal += premioRanking.creditos;
        posicaoRanking = premioRanking.posicao;
        tipoPremiacao = 'ranking';
      }
      
      // Verificar sortudo vencedor
      if (detalhes.sortudoVencedor?.odId === uid) {
        premioTotal += detalhes.sortudoVencedor.creditos;
        if (!tipoPremiacao) tipoPremiacao = 'sortudo_vencedor';
      }
      
      // Verificar sortudo popular
      if (detalhes.sortudoPopular?.odId === uid) {
        premioTotal += detalhes.sortudoPopular.creditos;
        if (!tipoPremiacao) tipoPremiacao = 'sortudo_popular';
      }
      
      if (premioTotal > 0) {
        // Aguardar um pouco e mostrar anima√ß√£o de vit√≥ria
        setTimeout(() => {
          mostrarAnimacaoVitoria(posicaoRanking, premioTotal, tipoPremiacao);
        }, 500);
      }
    }

    // ===================================
    // üîô VOLTAR AO PAINEL
    // ===================================
    function voltarPainel() {
      stopQuestionTimer();
      if (confirm("Deseja realmente sair do jogo?")) {
        window.location.href = "painel.html";
      }
    }

    // ===================================
    // üî• ATUALIZAR STREAK
    // ===================================
    function atualizarStreak(acertou) {
      if (acertou) {
        streak++;
        totalAcertos++;
        if (streak > maxStreak) maxStreak = streak;
        
        // Calcular multiplicador
        if (streak >= 10) multiplicador = 3;
        else if (streak >= 5) multiplicador = 2;
        else if (streak >= 3) multiplicador = 1.5;
        else multiplicador = 1;
        
        // Verificar conquistas
        verificarConquistas();
        
      } else {
        streak = 0;
        totalErros++;
        multiplicador = 1;
      }

      // Atualizar UI
      const streakBadge = document.getElementById('streakBadge');
      const streakCount = document.getElementById('streakCount');
      const multiplierBadge = document.getElementById('multiplierBadge');
      const multiplierValue = document.getElementById('multiplierValue');

      streakCount.textContent = streak;
      
      if (streak >= 3) {
        streakBadge.classList.add('active');
        multiplierBadge.style.display = 'flex';
        multiplierValue.textContent = multiplicador;
      } else {
        streakBadge.classList.remove('active');
        multiplierBadge.style.display = 'none';
      }
    }

    // ===================================
    // üèÖ VERIFICAR CONQUISTAS
    // ===================================
    function verificarConquistas() {
      // Primeiro acerto
      if (totalAcertos === 1 && !conquistasDesbloqueadas.includes('primeiroAcerto')) {
        mostrarConquista(CONQUISTAS.primeiroAcerto);
        conquistasDesbloqueadas.push('primeiroAcerto');
      }

      // Streak 3
      if (streak === 3 && !conquistasDesbloqueadas.includes('streak3')) {
        mostrarConquista(CONQUISTAS.streak3);
        conquistasDesbloqueadas.push('streak3');
      }

      // Streak 5
      if (streak === 5 && !conquistasDesbloqueadas.includes('streak5')) {
        mostrarConquista(CONQUISTAS.streak5);
        conquistasDesbloqueadas.push('streak5');
      }

      // Streak 10
      if (streak === 10 && !conquistasDesbloqueadas.includes('streak10')) {
        mostrarConquista(CONQUISTAS.streak10);
        conquistasDesbloqueadas.push('streak10');
      }

      // 10 acertos sem errar
      if (totalAcertos >= 10 && totalErros === 0 && !conquistasDesbloqueadas.includes('perfeito')) {
        mostrarConquista(CONQUISTAS.perfeito);
        conquistasDesbloqueadas.push('perfeito');
      }
    }

    // ===================================
    // üèÖ MOSTRAR CONQUISTA
    // ===================================
    async function mostrarConquista(conquista) {
      // Criar overlay
      const overlay = document.createElement('div');
      overlay.className = 'achievement-overlay';
      document.body.appendChild(overlay);

      // Criar popup
      const popup = document.createElement('div');
      popup.className = 'achievement-popup';
      popup.innerHTML = `
        <div class="emoji">${conquista.emoji}</div>
        <div class="title">üèÖ ${conquista.nome}</div>
        <div class="description">${conquista.descricao}</div>
        <div class="bonus">+${conquista.xpBonus} XP B√¥nus!</div>
      `;
      document.body.appendChild(popup);

      // Dar XP b√¥nus
      try {
        await db.collection('usuarios').doc(uid).update({
          xp: firebase.firestore.FieldValue.increment(conquista.xpBonus),
          [`conquistas.${conquista.id}`]: {
            data: new Date().toISOString(),
            jogoId: jogoId
          }
        });
      } catch (e) {
        console.error("Erro ao salvar conquista:", e);
      }

      // Remover ap√≥s 2.5 segundos
      setTimeout(() => {
        popup.remove();
        overlay.remove();
      }, 2500);
    }

    // ===================================
    // üí∞ SISTEMA DE PATROCINADORES
    // ===================================
    let sponsorTimeout = null;
    let patrocinadoresJogo = [];        // Lista de patrocinadores da partida
    let patrocinadorAtualIndex = 0;     // √çndice do pr√≥ximo patrocinador
    let contadorRespostas = 0;          // Contador de respostas para mostrar a cada 5
    let patrocinadorPendente = null;    // Patrocinador atual sendo mostrado
    
    // Carregar patrocinadores da partida
    async function carregarPatrocinadores() {
      try {
        const jogoDoc = await db.collection("jogos").doc(jogoId).get();
        const jogo = jogoDoc.data();
        
        if (jogo.patrocinadores && jogo.patrocinadores.length > 0) {
          patrocinadoresJogo = jogo.patrocinadores;
          console.log(`üì¢ ${patrocinadoresJogo.length} patrocinadores carregados`);
        } else {
          console.log("üì¢ Nenhum patrocinador cadastrado para esta partida");
          patrocinadoresJogo = [];
        }
        
        // Carregar √≠ndice do usu√°rio (para continuar de onde parou)
        const userDoc = await db.collection("usuarios").doc(uid).get();
        const userData = userDoc.data() || {};
        patrocinadorAtualIndex = userData.patrocinadorIndex?.[jogoId] || 0;
        contadorRespostas = userData.contadorRespostas?.[jogoId] || 0;
        
      } catch (error) {
        console.error("‚ùå Erro ao carregar patrocinadores:", error);
        patrocinadoresJogo = [];
      }
    }
    
    // Verificar se deve mostrar patrocinador (a cada 5 respostas)
    function verificarPatrocinador() {
      contadorRespostas++;
      
      // Salvar contador no usu√°rio
      db.collection("usuarios").doc(uid).update({
        [`contadorRespostas.${jogoId}`]: contadorRespostas
      }).catch(e => console.error("Erro ao salvar contador:", e));
      
      // A cada 5 respostas, mostrar patrocinador
      if (contadorRespostas % 5 === 0 && patrocinadoresJogo.length > 0) {
        setTimeout(() => mostrarPatrocinador(), 1500);
      }
    }
    
    // Mostrar patrocinador atual
    function mostrarPatrocinador() {
      if (patrocinadoresJogo.length === 0) {
        console.log("üì¢ Nenhum patrocinador dispon√≠vel");
        return;
      }
      
      // Pegar patrocinador atual (ciclo)
      const sponsor = patrocinadoresJogo[patrocinadorAtualIndex % patrocinadoresJogo.length];
      patrocinadorPendente = sponsor;
      
      console.log(`üì¢ Mostrando patrocinador: ${sponsor.nome} (${patrocinadorAtualIndex + 1}/${patrocinadoresJogo.length})`);
      
      // Remover popup anterior se existir
      const existingPopup = document.getElementById('sponsorPopup');
      if (existingPopup) existingPopup.remove();
      
      // Criar popup
      const popup = document.createElement('div');
      popup.className = 'sponsor-popup active';
      popup.id = 'sponsorPopup';
      
      // Logo pode ser emoji ou URL de imagem
      const logoDisplay = sponsor.logoUrl 
        ? `<img src="${sponsor.logoUrl}" alt="${sponsor.nome}" class="sponsor-logo-img">`
        : `<div class="sponsor-logo">${sponsor.logo || 'üéÅ'}</div>`;
      
      popup.innerHTML = `
        <div class="sponsor-header">üì¢ Patrocinador da Partida</div>
        ${logoDisplay}
        <div class="sponsor-name">${sponsor.nome}</div>
        ${sponsor.descricao ? `<div class="sponsor-desc">${sponsor.descricao}</div>` : ''}
        <div class="sponsor-reward">
          üéÅ Visite o site e ganhe <strong>${sponsor.creditos}</strong> cr√©dito${sponsor.creditos > 1 ? 's' : ''}!
        </div>
        <button class="sponsor-btn" onclick="resgatarPatrocinador()">
          üåê Visitar e Resgatar
        </button>
        <button class="sponsor-skip" onclick="fecharPatrocinador()">
          Pular desta vez
        </button>
        <div class="sponsor-timer">
          <span id="sponsorCountdown">15</span>s para fechar automaticamente
        </div>
      `;
      document.body.appendChild(popup);
      
      // Countdown visual
      let countdown = 15;
      const countdownEl = document.getElementById('sponsorCountdown');
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdownEl) countdownEl.textContent = countdown;
        if (countdown <= 0) clearInterval(countdownInterval);
      }, 1000);

      // Auto-fechar ap√≥s 15 segundos
      sponsorTimeout = setTimeout(() => {
        fecharPatrocinador();
        clearInterval(countdownInterval);
      }, 15000);
    }
    
    // Resgatar patrocinador (abre site + credita pontos)
    async function resgatarPatrocinador() {
      if (!patrocinadorPendente) return;
      
      const sponsor = patrocinadorPendente;
      
      try {
        // Abrir site do patrocinador em nova aba
        if (sponsor.url) {
          window.open(sponsor.url, '_blank');
        }
        
        // Creditar pontos ao usu√°rio
        await db.collection('usuarios').doc(uid).update({
          creditos: firebase.firestore.FieldValue.increment(sponsor.creditos),
          // Salvar hist√≥rico de patrocinadores resgatados
          [`patrocinadoresResgatados.${jogoId}`]: firebase.firestore.FieldValue.arrayUnion({
            nome: sponsor.nome,
            creditos: sponsor.creditos,
            timestamp: new Date().toISOString()
          }),
          // Avan√ßar para pr√≥ximo patrocinador
          [`patrocinadorIndex.${jogoId}`]: (patrocinadorAtualIndex + 1) % patrocinadoresJogo.length
        });
        
        // Avan√ßar √≠ndice local
        patrocinadorAtualIndex = (patrocinadorAtualIndex + 1) % patrocinadoresJogo.length;
        
        showToast(`üéÅ +${sponsor.creditos} cr√©dito${sponsor.creditos > 1 ? 's' : ''} de ${sponsor.nome}!`);
        fecharPatrocinador();
        updateFreePlays();
        
      } catch (e) {
        console.error("Erro ao resgatar patrocinador:", e);
        showToast("‚ùå Erro ao resgatar. Tente novamente!");
      }
    }

    function fecharPatrocinador() {
      if (sponsorTimeout) {
        clearTimeout(sponsorTimeout);
        sponsorTimeout = null;
      }
      const popup = document.getElementById('sponsorPopup');
      if (popup) popup.remove();
      patrocinadorPendente = null;
      
      // Avan√ßar para pr√≥ximo patrocinador mesmo pulando
      patrocinadorAtualIndex = (patrocinadorAtualIndex + 1) % Math.max(1, patrocinadoresJogo.length);
      
      // Salvar √≠ndice
      db.collection("usuarios").doc(uid).update({
        [`patrocinadorIndex.${jogoId}`]: patrocinadorAtualIndex
      }).catch(e => console.error("Erro ao salvar √≠ndice:", e));
    }
    
    // ‚úÖ FUN√á√ÉO TOAST - Mensagens tempor√°rias
    function showToast(message, duration = 3000) {
      // Remover toast anterior se existir
      const existingToast = document.getElementById('toastNotification');
      if (existingToast) existingToast.remove();
      
      const toast = document.createElement('div');
      toast.id = 'toastNotification';
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, var(--bg-card), var(--bg-secondary));
        color: var(--text-primary);
        padding: 15px 25px;
        border-radius: 12px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        border: 1px solid rgba(255,181,71,0.3);
        animation: toastSlideUp 0.3s ease;
      `;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'toastSlideDown 0.3s ease';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }

    console.log("‚úÖ Yellup Game v7.0 - Chat em tempo real + Status por hor√°rio!");
  </script>

</body>
</html>
